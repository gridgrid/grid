{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "node_modules/capitalize/index.js",
    "node_modules/element-class/index.js",
    "node_modules/key/lib/code/alnum.js",
    "node_modules/key/lib/code/arrow.js",
    "node_modules/key/lib/code/brand.js",
    "node_modules/key/lib/code/punctuation.js",
    "node_modules/key/lib/code/special.js",
    "node_modules/key/lib/key.js",
    "node_modules/key/lib/ref.js",
    "src/modules/abstract-row-col-model/index.js",
    "src/modules/add-dirty-props/index.js",
    "src/modules/angular-builder/index.js",
    "src/modules/angular-decorator/index.js",
    "src/modules/cell-classes/index.js",
    "src/modules/cell-mouse-model/index.js",
    "src/modules/cell-scroll-model/index.js",
    "src/modules/col-model/index.js",
    "src/modules/col-reorder/index.js",
    "src/modules/col-resize/index.js",
    "src/modules/copy-paste/index.js",
    "src/modules/core/index.js",
    "src/modules/ctrl-or-cmd/index.js",
    "src/modules/custom-event/index.js",
    "src/modules/debounce/index.js",
    "src/modules/decorators/index.js",
    "src/modules/dirty-clean/index.js",
    "src/modules/event-loop/index.js",
    "src/modules/grid-entry.js",
    "src/modules/header-decorators/index.js",
    "src/modules/listeners/index.js",
    "src/modules/mousewheel/index.js",
    "src/modules/navigation-model/index.js",
    "src/modules/no-op/index.js",
    "src/modules/pass-through/index.js",
    "src/modules/pixel-scroll-model/index.js",
    "src/modules/position-range/index.js",
    "src/modules/range-util/index.js",
    "src/modules/row-model/index.js",
    "src/modules/show-hidden-cols/index.js",
    "src/modules/simple-data-model/index.js",
    "src/modules/tsv/index.js",
    "src/modules/util/index.js",
    "src/modules/view-layer/index.js",
    "src/modules/view-port/index.js",
    "src/modules/virtual-pixel-cell-model/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzWA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5pBA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "module.exports = function (string) {\n  return string.charAt(0).toUpperCase() + string.substring(1);\n}\n\nmodule.exports.words = function (string) {\n  return string.replace(/(^|\\W)(\\w)/g, function (m) {\n    return m.toUpperCase()\n  })\n}\n",
    "module.exports = function(opts) {\n  return new ElementClass(opts)\n}\n\nfunction ElementClass(opts) {\n  if (!(this instanceof ElementClass)) return new ElementClass(opts)\n  var self = this\n  if (!opts) opts = {}\n\n  // similar doing instanceof HTMLElement but works in IE8\n  if (opts.nodeType) opts = {el: opts}\n\n  this.opts = opts\n  this.el = opts.el || document.body\n  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)\n}\n\nElementClass.prototype.add = function(className) {\n  var el = this.el\n  if (!el) return\n  if (el.className === \"\") return el.className = className\n  var classes = el.className.split(' ')\n  if (classes.indexOf(className) > -1) return classes\n  classes.push(className)\n  el.className = classes.join(' ')\n  return classes\n}\n\nElementClass.prototype.remove = function(className) {\n  var el = this.el\n  if (!el) return\n  if (el.className === \"\") return\n  var classes = el.className.split(' ')\n  var idx = classes.indexOf(className)\n  if (idx > -1) classes.splice(idx, 1)\n  el.className = classes.join(' ')\n  return classes\n}\n\nElementClass.prototype.has = function(className) {\n  var el = this.el\n  if (!el) return\n  var classes = el.className.split(' ')\n  return classes.indexOf(className) > -1\n}\n",
    "// Generated by CoffeeScript 1.3.3\n(function() {\n  'use strict';\n\n  var alnum, ref;\n\n  ref = require('../ref').ref;\n\n  alnum = {\n    '0': ref('0', 48),\n    '1': ref('1', 49),\n    '2': ref('2', 50),\n    '3': ref('3', 51),\n    '4': ref('4', 52),\n    '5': ref('5', 53),\n    '6': ref('6', 54),\n    '7': ref('7', 55),\n    '8': ref('8', 56),\n    '9': ref('9', 57),\n    a: ref('A', 65),\n    b: ref('B', 66),\n    c: ref('C', 67),\n    d: ref('D', 68),\n    e: ref('E', 69),\n    f: ref('F', 70),\n    g: ref('G', 71),\n    h: ref('H', 72),\n    i: ref('I', 73),\n    j: ref('J', 74),\n    k: ref('K', 75),\n    l: ref('L', 76),\n    m: ref('M', 77),\n    n: ref('N', 78),\n    o: ref('O', 79),\n    p: ref('P', 80),\n    q: ref('Q', 81),\n    r: ref('R', 82),\n    s: ref('S', 83),\n    t: ref('T', 84),\n    u: ref('U', 85),\n    v: ref('V', 86),\n    w: ref('W', 87),\n    x: ref('X', 88),\n    y: ref('Y', 89),\n    z: ref('Z', 90)\n  };\n\n  module.exports = alnum;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.3.3\n(function() {\n  'use strict';\n\n  var arrow, ref;\n\n  ref = require('../ref').ref;\n\n  arrow = {\n    left: ref('Left', 37),\n    up: ref('Up', 38),\n    right: ref('Right', 39),\n    down: ref('Down', 40)\n  };\n\n  module.exports = arrow;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.3.3\n(function() {\n  'use strict';\n\n  var brand, ref;\n\n  ref = require('../ref').ref;\n\n  brand = {\n    apple: ref('Apple &#8984;', 224),\n    windows: {\n      start: ref('Windows start', [91, 92]),\n      menu: ref('Windows menu', 93)\n    }\n  };\n\n  module.exports = brand;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.3.3\n(function() {\n  'use strict';\n\n  var punctuation, ref;\n\n  ref = require('../ref').ref;\n\n  punctuation = {\n    colon: ref('Colon/Semicolon', [59, 186]),\n    equal: ref('Equal/Plus', [61, 187]),\n    comma: ref('Comma/Less Than', [44, 188]),\n    hyphen: ref('Hyphen/Underscore', [45, 109, 189]),\n    period: ref('Period/Greater Than', [46, 190]),\n    tilde: ref('Tilde/Back Tick', [96, 192]),\n    apostrophe: ref('Apostrophe/Quote', [39, 222]),\n    slash: {\n      forward: ref('Forward Slash/Question Mark', [47, 191]),\n      backward: ref('Backward Slash/Pipe', 220)\n    },\n    brace: {\n      square: {\n        open: ref('Open Square/Curly Brace', 219),\n        close: ref('Close Square/Curly Brace', 221)\n      }\n    }\n  };\n\n  punctuation.semicolon = punctuation.colon;\n\n  punctuation.plus = punctuation.equal;\n\n  punctuation.lessthan = punctuation.comma;\n\n  punctuation.underscore = punctuation.hyphen;\n\n  punctuation.greaterthan = punctuation.period;\n\n  punctuation.question = punctuation.slash.forward;\n\n  punctuation.backtick = punctuation.tilde;\n\n  punctuation.pipe = punctuation.slash.backward;\n\n  punctuation.quote = punctuation.apostrophe;\n\n  punctuation.brace.curly = punctuation.brace.square;\n\n  module.exports = punctuation;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.3.3\n(function() {\n  'use strict';\n\n  var ref, special;\n\n  ref = require('../ref').ref;\n\n  special = {\n    backspace: ref('Backspace', 8),\n    tab: ref('Tab', 9),\n    enter: ref('Enter', 13),\n    shift: ref('Shift', 16),\n    ctrl: ref('Ctrl', 17),\n    alt: ref('Alt', 18),\n    caps: ref('Caps Lock', 20),\n    esc: ref('Escape', 27),\n    space: ref('Space', 32),\n    num: ref('Num Lock', 144)\n  };\n\n  module.exports = special;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.3.3\n(function() {\n  'use strict';\n\n  var isRef, iterator, key,\n    _this = this,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __hasProp = {}.hasOwnProperty;\n\n  isRef = require('./ref').isRef;\n\n  key = {};\n\n  key.code = {\n    special: require('./code/special'),\n    arrow: require('./code/arrow'),\n    punctuation: require('./code/punctuation'),\n    alnum: require('./code/alnum'),\n    brand: require('./code/brand')\n  };\n\n  key.get = function(pressed) {\n    return iterator(key.code, pressed);\n  };\n\n  key.is = function(ref, pressed) {\n    if (!isRef(ref)) {\n      ref = iterator(ref, pressed);\n    }\n    if (isRef(ref)) {\n      if (isRef(pressed)) {\n        return pressed === ref;\n      } else {\n        return pressed === ref.code || __indexOf.call(ref.code, pressed) >= 0;\n      }\n    } else {\n      return pressed === ref;\n    }\n  };\n\n  iterator = function(context, pressed) {\n    var i, out, ref;\n    for (i in context) {\n      if (!__hasProp.call(context, i)) continue;\n      ref = context[i];\n      if (isRef(ref)) {\n        if (key.is(ref, pressed)) {\n          return ref;\n        }\n      } else {\n        out = iterator(ref, pressed);\n        if (isRef(out)) {\n          return out;\n        }\n      }\n    }\n  };\n\n  if (typeof window !== 'undefined') {\n    window.key = key;\n  }\n\n  module.exports = key;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.3.3\n(function() {\n  'use strict';\n\n  var Reference, assertRef, isRef, ref;\n\n  Reference = (function() {\n\n    function Reference(name, code) {\n      this.name = name;\n      this.code = code;\n    }\n\n    return Reference;\n\n  })();\n\n  ref = function(name, code) {\n    return new Reference(name, code);\n  };\n\n  isRef = function(ref) {\n    return ref instanceof Reference;\n  };\n\n  assertRef = function(ref) {\n    if (!isRef(ref)) {\n      throw new Error('Invalid reference');\n    }\n    return ref;\n  };\n\n  module.exports = {\n    ref: ref,\n    isRef: isRef,\n    assertRef: assertRef\n  };\n\n}).call(this);\n",
    "var addDirtyProps = require('../add-dirty-props');\nvar util = require('../util');\nvar noop = require('../no-op');\nvar passThrough = require('../pass-through');\nvar debounce = require('../debounce');\n\nmodule.exports = function(_grid, name, lengthName, defaultSize) {\n    var grid = _grid;\n\n    var descriptors = [];\n    var numFixed = 0;\n    var numHeaders = 0;\n    var makeDirtyClean = require('../dirty-clean');\n    var dirtyClean = makeDirtyClean(grid);\n    var builderDirtyClean = makeDirtyClean(grid);\n    var selected = [];\n\n\n    function setDescriptorsDirty(eventOptional) {\n        var event = eventOptional || {};\n        event.type = 'grid-' + name + '-change';\n        grid.eventLoop.fire(event);\n        dirtyClean.setDirty();\n        builderDirtyClean.setDirty();\n    }\n\n    var fireSelectionChange = debounce(function() {\n        grid.eventLoop.fire('grid-' + name + '-selection-change');\n    }, 1);\n\n    function updateDescriptorIndices() {\n        var oldSelected = selected;\n        selected = [];\n        descriptors.forEach(function(descriptor, i) {\n            descriptor.index = i;\n            if (descriptor.selected) {\n                selected.push(i);\n            }\n        });\n        if (selected.length !== oldSelected.length) {\n            fireSelectionChange();\n        }\n        selected.sort();\n        oldSelected.sort();\n        var change = oldSelected.some(function(idx, i) {\n            return idx !== selected[i];\n        });\n        if (change) {\n            fireSelectionChange();\n        }\n    }\n\n    var api = {\n        areBuildersDirty: builderDirtyClean.isDirty,\n        isDirty: dirtyClean.isDirty,\n        defaultSize: defaultSize,\n        add: function(toAdd) {\n            if (!toAdd) {\n                return;\n            }\n\n            if (!util.isArray(toAdd)) {\n                toAdd = [toAdd];\n            }\n            toAdd.forEach(function(descriptor) {\n                if (descriptor.header) {\n                    descriptors.splice(numHeaders, 0, descriptor);\n                    numFixed++;\n                    numHeaders++;\n                } else {\n                    // if the column is fixed and the last one added is fixed (we only allow fixed at the beginning for now)\n                    if (descriptor.fixed) {\n                        if (!descriptors.length || descriptors[descriptors.length - 1].fixed) {\n                            numFixed++;\n                        } else {\n                            throw 'Cannot add a fixed column after an unfixed one';\n                        }\n                    }\n                    descriptors.push(descriptor);\n                }\n            });\n            updateDescriptorIndices();\n            setDescriptorsDirty({\n                action: 'add',\n                descriptors: toAdd\n            });\n        },\n        addHeaders: function(toAdd) {\n            if (!toAdd) {\n                return;\n            }\n\n            if (!util.isArray(toAdd)) {\n                toAdd = [toAdd];\n            }\n            toAdd.forEach(function(header) {\n                header.header = true;\n            });\n            api.add(toAdd);\n        },\n        header: function(index) {\n            return descriptors[index];\n        },\n        get: function(index) {\n            return descriptors[index];\n        },\n        length: function(includeHeaders) {\n            var subtract = includeHeaders ? 0 : numHeaders;\n            return descriptors.length - subtract;\n        },\n        remove: function(descriptor, dontUpdateIndex) {\n            var index = descriptors.indexOf(descriptor);\n            if (index !== -1) {\n                descriptors.splice(index, 1);\n                if (descriptor.header) {\n                    numFixed--;\n                    numHeaders--;\n                } else if (descriptor.fixed) {\n                    numFixed--;\n                }\n            }\n            if (!dontUpdateIndex) {\n                updateDescriptorIndices();\n                setDescriptorsDirty({\n                    action: 'remove',\n                    descriptors: [descriptor]\n                });\n            }\n        },\n        clear: function(includeHeaders) {\n            var removed;\n            if (includeHeaders) {\n                removed = descriptors;\n                descriptors = [];\n                numFixed = 0;\n                numHeaders = 0;\n            } else {\n                removed = descriptors.slice(numHeaders);\n                descriptors = descriptors.slice(0, numHeaders);\n                numFixed = numHeaders;\n            }\n            updateDescriptorIndices();\n            if (removed && removed.length) {\n                setDescriptorsDirty({\n                    action: 'remove',\n                    descriptors: removed\n                });\n            }\n        },\n        move: function(fromIndexes, target, after) {\n            if (!util.isArray(fromIndexes)) {\n                fromIndexes = [fromIndexes];\n            }\n\n            if (fromIndexes.length === 1) {\n                // the single move case is easier and doesn't require the after hint\n                var from = fromIndexes[0];\n                descriptors.splice(target, 0, descriptors.splice(from, 1)[0]);\n                setDescriptorsDirty({\n                    action: 'move',\n                    descriptors: [api.get(from), api.get(target)]\n                });\n            } else {\n                while (fromIndexes.indexOf(target) !== -1 && target !== -1) {\n                    target--;\n                    after = true;\n                }\n\n                var toValue = descriptors[target];\n                var removed = fromIndexes.sort(function compareNumbers(a, b) {\n                    return b - a;\n                }).map(function(fromIndex) {\n                    var removedDescriptors = descriptors.splice(fromIndex, 1);\n                    return removedDescriptors[0];\n\n                });\n                removed.reverse();\n                var spliceArgs = [descriptors.indexOf(toValue) + (after ? 1 : 0), 0].concat(removed);\n                descriptors.splice.apply(descriptors, spliceArgs);\n                updateDescriptorIndices();\n                setDescriptorsDirty({\n                    action: 'move',\n                    descriptors: removed.concat(toValue)\n                });\n            }\n        },\n        numHeaders: function() {\n            return numHeaders;\n        },\n        numFixed: function(excludeHeaders) {\n            return numFixed - (excludeHeaders ? numHeaders : 0);\n        },\n        toVirtual: function(dataIndex) {\n            return dataIndex + api.numHeaders();\n        },\n        toData: function(virtualIndex) {\n            return virtualIndex - api.numHeaders();\n        },\n\n        select: function(indexes, dontFire) {\n            if (!util.isArray(indexes)) {\n                indexes = [indexes];\n            }\n            var changes = indexes.filter(function(idx) {\n                var hasDescriptor = !!api[name](idx);\n                if (!hasDescriptor) {\n                    console.warn('Tried to select index that had no descriptor', idx);\n                }\n                return hasDescriptor;\n            }).map(function(idx) {\n                var descriptor = api[name](idx);\n                if (!descriptor.selected && descriptor.selectable !== false) {\n                    descriptor.selected = true;\n                    selected.push(idx);\n                    return idx;\n                }\n            });\n            if (changes.length && !dontFire) {\n                fireSelectionChange();\n            }\n        },\n        deselect: function(indexes, dontFire) {\n            if (!util.isArray(indexes)) {\n                indexes = [indexes];\n            }\n            var changes = indexes.filter(function(idx) {\n                var hasDescriptor = !!api[name](idx);\n                if (!hasDescriptor) {\n                    console.warn('Tried to deselect index that had no descriptor', idx);\n                }\n                return hasDescriptor;\n            }).map(function(idx) {\n                var descriptor = api[name](idx);\n                if (descriptor.selected) {\n                    descriptor.selected = false;\n                    selected.splice(selected.indexOf(idx), 1);\n                    return idx;\n                }\n            });\n            if (changes.length && !dontFire) {\n                fireSelectionChange();\n            }\n        },\n        toggleSelect: function(index) {\n            var descriptor = api[name](index);\n            if (descriptor.selected) {\n                api.deselect(index);\n            } else {\n                api.select(index);\n            }\n        },\n        clearSelected: function() {\n            // have to make a copy or we are iterating the same array we're removing from yikes.\n            return api.deselect(api.getSelected().slice(0));\n        },\n        getSelected: function() {\n            return selected;\n        },\n        allSelected: function() {\n            return api.getSelected().length === api.length();\n        },\n        create: function(builder) {\n            var descriptor = {};\n            var fixed = false;\n            Object.defineProperty(descriptor, 'fixed', {\n                enumerable: true,\n                get: function() {\n                    return descriptor.header || fixed;\n                },\n                set: function(_fixed) {\n                    fixed = _fixed;\n                }\n            });\n            var expanded = false;\n            var expandedClass;\n            Object.defineProperty(descriptor, 'expanded', {\n                get: function() {\n                    return expanded;\n                },\n                set: function(exp) {\n                    if (!descriptor.children) {\n                        return;\n                    }\n                    expanded = exp;\n                    // we never look for changes to the children, if you need to change it, remove and add the row again\n                    if (expanded) {\n                        var spliceArgs = [descriptor.index + 1, 0].concat(descriptor.children)\n                        descriptors.splice.apply(descriptors, spliceArgs);\n                        updateDescriptorIndices();\n                        setDescriptorsDirty({\n                            action: 'add',\n                            descriptors: descriptor.children\n                        });\n                        var top = name === 'row' ? descriptor.index : 0;\n                        var left = name === 'col' ? descriptor.index : 0;\n                        var height = name === 'row' ? 1 : Infinity;\n                        var width = name === 'col' ? 1 : Infinity;\n                        expandedClass = grid.cellClasses.create(top, left, 'grid-expanded', height, width, 'virtual');\n                        grid.cellClasses.add(expandedClass);\n\n                    } else {\n                        descriptors.splice(descriptor.index + 1, descriptor.children.length);\n                        updateDescriptorIndices();\n                        setDescriptorsDirty({\n                            action: 'remove',\n                            descriptors: [descriptor.children]\n                        });\n                        if (expandedClass) {\n                            grid.cellClasses.remove(expandedClass);\n                        }\n                    }\n                }\n            });\n\n            addDirtyProps(descriptor, ['builder'], [builderDirtyClean]);\n            descriptor.builder = builder;\n\n            return addDirtyProps(descriptor, [{\n                name: lengthName,\n                onDirty: function() {\n                    setDescriptorsDirty({\n                        action: 'size',\n                        descriptors: [descriptor]\n                    });\n                }\n            }, {\n                name: 'hidden',\n                onDirty: function() {\n                    setDescriptorsDirty({\n                        action: 'hide',\n                        descriptors: [descriptor]\n                    });\n                }\n            }], [dirtyClean]);\n        },\n        createBuilder: function(render, update) {\n            return {\n                render: render || noop,\n                update: update || passThrough\n            };\n        }\n\n    };\n\n    // basically height or width\n    api[lengthName] = function(index) {\n        var descriptor = descriptors[index];\n        if (!descriptor) {\n            return NaN;\n        }\n\n\n        if (descriptor.hidden) {\n            return 0;\n        }\n\n        return descriptor[lengthName] || api.defaultSize;\n    };\n\n    // row or col get\n    api[name] = function(index) {\n        return descriptors[index + numHeaders];\n    };\n\n    return api;\n};",
    "module.exports = function(obj, props, dirtyCleans) {\n    props.forEach(function(prop) {\n        var val;\n        var name = prop.name || prop;\n        Object.defineProperty(obj, name, {\n            enumerable: true,\n            get: function() {\n                return val;\n            },\n            set: function(_val) {\n                var oldVal = val;\n                var isChanged = _val !== oldVal\n                if (isChanged && prop.preDirty) {\n                    prop.preDirty();\n                }\n                val = _val;\n\n                if (isChanged) {\n                    dirtyCleans.forEach(function(dirtyClean) {\n                        dirtyClean.setDirty();\n                    });\n                    if (prop.onDirty) {\n                        prop.onDirty(_val, oldVal);\n                    }\n                }\n            }\n        });\n    });\n    return obj;\n};",
    "var moduleName = 'grid-builder';\nmodule.exports = moduleName;\n\nangular.module(moduleName, [])\n\n.factory('GridBuilderSrvc', function($compile) {\n    var GridBuilderSrvc = {};\n\n    GridBuilderSrvc.destroy = function(elem) {\n        if (elem) {\n            var $prevElem = angular.element(elem);\n            // if this thing doesn't actually have scope we will be destroying an inherited scope which is baaaaad\n            if (!$prevElem.data('$scope')) {\n                return;\n            }\n            var $previousScope = $prevElem.scope();\n            if ($previousScope) {\n                $previousScope.$destroy();\n            }\n            $prevElem.remove();\n        }\n    }\n\n    GridBuilderSrvc.render = function($scope, tpl, initScopeFn) {\n        var scope = $scope.$new();\n        if (initScopeFn) {\n            initScopeFn(scope);\n        }\n        var $elem = $compile(tpl)(scope);\n\n        $elem.on('grid-rendered-elem-destroy', function() {\n            GridBuilderSrvc.destroy($elem);\n        });\n        return $elem[0];\n    };\n\n    return GridBuilderSrvc;\n});",
    "var moduleName = 'grid-decorator';\nmodule.exports = moduleName;\n\nangular.module(moduleName, [])\n\n.factory('GridDecoratorSrvc', function($compile) {\n    var GridDecoratorSrvc = {\n        render: function(opts) {\n            var compiled = $compile(opts.template)(opts.$scope);\n            opts.$scope.$digest();\n\n            // this absolutely has to happend after apply or the binding is to the wrong element (in fact anything you need to do has to happen after the apply)\n            compiled.on('decorator-destroy', function() {\n                opts.$scope.$destroy();\n                // unbind in a timeout to allow any other listeners to fire first\n                setTimeout(function() {\n                    compiled.remove();\n                    compiled.off('decorator-destroy');\n                }, 1);\n            });\n            if (opts.events) {\n                compiled[0].style.pointerEvents = 'all';\n            }\n            return compiled[0];\n        },\n        headerDecorators: function(grid, model) {\n            var origAnnotate = model.annotateDecorator;\n            model.annotateDecorator = function(dec) {\n                dec.render = function() {\n                    return GridDecoratorSrvc.render(dec.renderOpts);\n                };\n                if (origAnnotate) {\n                    origAnnotate(dec);\n                }\n            };\n\n            require('../header-decorators')(grid, model);\n        }\n    };\n    return GridDecoratorSrvc\n})\n\n;",
    "var positionRange = require('../position-range');\nvar makeDirtyClean = require('../dirty-clean');\nvar addDirtyProps = require('../add-dirty-props');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n\n    var dirtyClean = makeDirtyClean(grid);\n    var descriptors = [];\n    var cachedClassMatrix = [];\n\n    var api = {\n        add: function(descriptor) {\n            descriptors.push(descriptor);\n            addOrRemoveCachedClass(descriptor);\n            dirtyClean.setDirty();\n        },\n        remove: function(descriptor) {\n            var index = descriptors.indexOf(descriptor);\n            if (index !== -1) {\n                descriptors.splice(index, 1);\n                addOrRemoveCachedClass(descriptor, true);\n                dirtyClean.setDirty();\n            }\n        },\n        getAll: function() {\n            return descriptors.slice(0);\n        },\n        getCachedClasses: function(vRow, vCol) {\n            return cachedClassMatrix[vRow] && cachedClassMatrix[vRow][vCol] || [];\n        },\n        create: function(top, left, className, height, width, space) {\n            var thisDirtyClean = makeDirtyClean(grid);\n            var descriptor = {};\n            // mixins\n\n            function classPreDirty() {\n                addOrRemoveCachedClass(descriptor, true);\n            }\n\n            function classOnDirty() {\n                addOrRemoveCachedClass(descriptor);\n            }\n\n            positionRange(descriptor, thisDirtyClean, dirtyClean, {\n                preDirty: classPreDirty,\n                onDirty: classOnDirty\n            });\n            addDirtyProps(descriptor, [{\n                name: 'class',\n                preDirty: classPreDirty,\n                onDirty: classOnDirty\n            }], [thisDirtyClean, dirtyClean]);\n\n            // all of these are optional\n            descriptor.top = top;\n            descriptor.left = left;\n            // default to single cell ranges\n            descriptor.height = height || 1;\n            descriptor.width = width || 1;\n            descriptor.class = className;\n            descriptor.space = space || descriptor.space;\n            return descriptor;\n        },\n        isDirty: dirtyClean.isDirty\n    };\n\n    function regnerateCache() {\n        cachedClassMatrix = [];\n        api.getAll().forEach(function(descriptor) {\n            addOrRemoveCachedClass(descriptor);\n        })\n    }\n\n    grid.eventLoop.bind('grid-row-change', regnerateCache);\n    grid.eventLoop.bind('grid-col-change', regnerateCache);\n\n    function addOrRemoveCachedClass(descriptor, isRemove) {\n        for (var r = descriptor.top; r < Math.min(descriptor.top + descriptor.height, grid.rowModel.length(true)); r++) {\n            for (var c = descriptor.left; c < Math.min(descriptor.left + descriptor.width, grid.colModel.length(true)); c++) {\n                var vRow = grid[descriptor.space].row.toVirtual(r);\n                var vCol = grid[descriptor.space].col.toVirtual(c);\n                var cols = cachedClassMatrix[vRow];\n                if (!cols) {\n                    cols = cachedClassMatrix[vRow] = [];\n                }\n                var cellClasses = cols[vCol];\n                if (!cellClasses) {\n                    if (!isRemove) {\n                        cols[vCol] = [descriptor.class];\n                    }\n                    continue;\n                }\n\n                if (!isRemove) {\n                    if (cellClasses.indexOf(descriptor.class) === -1) {\n                        cellClasses.push(descriptor.class);\n                    }\n                } else {\n                    var index = cellClasses.indexOf(descriptor.class);\n                    if (index !== -1) {\n                        cellClasses.splice(index, 1);\n                    }\n                }\n            }\n        }\n    }\n\n\n    return api;\n};",
    "var customEvent = require('../custom-event');\n\nvar PROPS_TO_COPY_FROM_MOUSE_EVENTS = ['clientX', 'clientY', 'gridX', 'gridY', 'layerX', 'layerY', 'row', 'col', 'realRow', 'realCol'];\n\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n\n    var model = {};\n\n    var scrollInterval;\n\n    model._annotateEvent = function annotateEvent(e) {\n        /*eslint-disable no-fallthrough*/\n        switch (e.type) {\n            case 'click':\n            case 'dblclick':\n            case 'mousedown':\n            case 'mousemove':\n            case 'mouseup':\n                model._annotateEventInternal(e);\n                break;\n        }\n        /*eslint-enable no-fallthrough*/\n    };\n\n    model._annotateEventFromViewCoords = function(e, viewRow, viewCol) {\n        e.realRow = viewRow;\n        e.realCol = viewCol;\n        e.virtualRow = grid.view.row.toVirtual(e.realRow);\n        e.virtualCol = grid.view.col.toVirtual(e.realCol);\n        e.row = grid.virtual.row.toData(e.virtualRow);\n        e.col = grid.virtual.col.toData(e.virtualCol);\n        return e;\n    };\n\n    model._annotateEventInternal = function(e) {\n        var y = grid.viewPort.toGridY(e.clientY);\n        var x = grid.viewPort.toGridX(e.clientX);\n        var viewRow = grid.viewPort.getRowByTop(y);\n        var viewCol = grid.viewPort.getColByLeft(x);\n        model._annotateEventFromViewCoords(e, viewRow, viewCol);\n        e.gridX = x;\n        e.gridY = y;\n    };\n\n    var lastMoveRow;\n    var lastMoveCol;\n    grid.eventLoop.addInterceptor(function(e) {\n        model._annotateEvent(e);\n        if (e.type === 'mousedown') {\n            if (e.currentTarget === grid.container) {\n                setupDragEventForMouseDown(e);\n            }\n        } else if (e.type === 'mousemove') {\n            if (e.row !== lastMoveRow || e.col !== lastMoveCol) {\n                createAndFireCustomMouseEvent('grid-cell-mouse-move', e);\n                lastMoveRow = e.row;\n                lastMoveCol = e.col;\n            }\n        }\n    });\n\n    function calculateColScrollDiff(e) {\n        var colDiff = 0;\n        if (e.clientX > (grid.container && grid.container.getBoundingClientRect().right || window.innerWidth)) {\n            colDiff = 1;\n        } else if (grid.viewPort.toGridX(e.clientX) < grid.virtualPixelCellModel.fixedWidth()) {\n            colDiff = -1;\n        }\n        return colDiff;\n    }\n\n    function calculateRowScrollDiff(e) {\n        var rowDiff = 0;\n        if (e.clientY > (grid.container && grid.container.getBoundingClientRect().bottom || window.innerHeight)) {\n            rowDiff = 1;\n        } else if (grid.viewPort.toGridY(e.clientY) < grid.virtualPixelCellModel.fixedHeight()) {\n            rowDiff = -1;\n        }\n        return rowDiff;\n    }\n\n    function setupDragEventForMouseDown(downEvent) {\n        var lastDragRow = downEvent.row;\n        var lastDragCol = downEvent.col;\n        var dragStarted = false;\n        var unbindAutoScrollDrag;\n        var lastX = downEvent.clientX;\n        var lastY = downEvent.clientY;\n        var unbindMove = grid.eventLoop.bind('mousemove', window, function(e) {\n\n\n            if (dragStarted && !e.which) {\n                // got a move event without mouse down which means we somehow missed the mouseup\n                console.log('mousemove unbind, how on earth do these happen?');\n                handleMouseUp(e);\n                return;\n            }\n\n            if (!dragStarted) {\n                if (lastX === e.clientX && lastY === e.clientY) {\n                    console.error('Got a mouse move event with ', e.clientX, ',', e.clientY, ' when the last position was ', lastX, ',', lastY);\n                }\n                createAndFireCustomMouseEvent('grid-drag-start', downEvent, function annotateDragStart(dragStart) {\n                    var onlyFixedRows = !calculateRowScrollDiff(e);\n                    var onlyFixedCols = !calculateColScrollDiff(e);\n                    dragStart.enableAutoScroll = function() {\n                        if (unbindAutoScrollDrag) {\n                            unbindAutoScrollDrag();\n                        }\n                        unbindAutoScrollDrag = grid.eventLoop.bind('grid-drag', function(e) {\n                            // if it gets here then we will try to auto scroll\n                            var newRowDiff = calculateRowScrollDiff(e);\n                            onlyFixedRows = !newRowDiff;\n                            var rowDiff = onlyFixedRows ? 0 : newRowDiff;\n\n\n                            var newColDiff = calculateColScrollDiff;\n                            onlyFixedCols = !newColDiff;\n                            var colDiff = onlyFixedCols ? 0 : newColDiff(e);\n\n                            clearInterval(scrollInterval);\n                            if (rowDiff || colDiff) {\n                                scrollInterval = grid.interval(function() {\n                                    grid.cellScrollModel.scrollTo(grid.cellScrollModel.row + rowDiff, grid.cellScrollModel.col + colDiff);\n                                }, 100);\n                            }\n\n                        });\n                    };\n                });\n                dragStarted = true;\n            }\n\n            createAndFireCustomMouseEvent('grid-drag', e);\n\n            if (e.row !== lastDragRow || e.col !== lastDragCol) {\n                createAndFireCustomMouseEvent('grid-cell-drag', e);\n\n                lastDragRow = e.row;\n                lastDragCol = e.col;\n            }\n\n        });\n\n        var unbindUp = grid.eventLoop.bind('mouseup', window, handleMouseUp);\n\n        function handleMouseUp(e) {\n            clearInterval(scrollInterval);\n            unbindMove();\n            unbindUp();\n            if (unbindAutoScrollDrag) {\n                unbindAutoScrollDrag();\n            }\n\n            var dragEnd = createCustomEventFromMouseEvent('grid-drag-end', e);\n\n            // row, col, x, and y should inherit\n            grid.eventLoop.fire(dragEnd);\n        }\n    }\n\n    function createCustomEventFromMouseEvent(type, e) {\n        var event = customEvent(type, true, true);\n        PROPS_TO_COPY_FROM_MOUSE_EVENTS.forEach(function(prop) {\n            event[prop] = e[prop];\n        });\n        event.originalEvent = e;\n        return event;\n    }\n\n    function createAndFireCustomMouseEvent(type, e, annotateEvent) {\n        var drag = createCustomEventFromMouseEvent(type, e);\n        if (annotateEvent) {\n            drag = annotateEvent(drag) || drag;\n        }\n        if (e.target) {\n            e.target.dispatchEvent(drag);\n        } else {\n            grid.eventLoop.fire(drag);\n        }\n        return drag;\n    }\n\n    return model;\n};",
    "var util = require('../util');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n    var dirtyClean = require('../dirty-clean')(grid);\n\n\n    var row;\n    var model = {\n        col: 0\n    };\n    Object.defineProperty(model, 'row', {\n        enumerable: true,\n        get: function() {\n            return row;\n        },\n        set: function(r) {\n            row = r;\n        }\n    });\n    model.row = 0;\n\n    model.isDirty = dirtyClean.isDirty;\n\n    grid.eventLoop.bind('grid-row-change', function(e) {\n        switch (e.action) {\n            case 'remove':\n                model.scrollTo(0, model.col);\n                break;\n        }\n    });\n\n    model.scrollTo = function(r, c, dontFire, fromPixelModel) {\n        if (isNaN(r) || isNaN(c)) {\n            return;\n        }\n        var maxRow = (grid.rowModel.length() || 1) - 1;\n        var maxCol = (grid.colModel.length() || 1) - 1;\n        var lastRow = model.row;\n        var lastCol = model.col;\n        model.row = util.clamp(r, 0, maxRow);\n        model.col = util.clamp(c, 0, maxCol);\n        if (lastRow !== model.row || lastCol !== model.col) {\n            dirtyClean.setDirty();\n\n            if (!dontFire) {\n                grid.eventLoop.fire('grid-cell-scroll');\n            }\n\n            if (!fromPixelModel) {\n                var top = grid.virtualPixelCellModel.height(grid.rowModel.numFixed(), model.row + grid.rowModel.numFixed() - 1);\n                var left = grid.virtualPixelCellModel.width(grid.colModel.numFixed(), model.col + grid.colModel.numFixed() - 1);\n                grid.pixelScrollModel.scrollTo(top, left, true);\n            }\n        }\n    };\n\n    function convertVirtualToScroll(virtualCoord, rowOrCol) {\n        return virtualCoord - grid[rowOrCol + 'Model'].numFixed();\n    }\n\n    function getScrollToRowOrCol(virtualCoord, rowOrCol, heightWidth) {\n        var currentScroll = model[rowOrCol];\n        var scrollTo = currentScroll;\n        if (grid.viewPort[rowOrCol + 'IsInView'](virtualCoord)) {\n            return scrollTo;\n        }\n\n        var targetScroll = convertVirtualToScroll(virtualCoord, rowOrCol);\n        if (targetScroll < currentScroll) {\n            scrollTo = targetScroll;\n        } else if (targetScroll > currentScroll) {\n\n            var lengthToCell = grid.virtualPixelCellModel[heightWidth](0, virtualCoord);\n            var numFixed = grid[rowOrCol + 'Model'].numFixed();\n            scrollTo = 0;\n            for (var i = numFixed; i < virtualCoord; i++) {\n                lengthToCell -= grid.virtualPixelCellModel[heightWidth](i);\n                scrollTo = i - (numFixed - 1);\n                if (lengthToCell <= grid.viewPort[heightWidth]) {\n                    break;\n                }\n            }\n        }\n\n        return scrollTo;\n    }\n\n    //for now assumes data space\n    model.scrollIntoView = function(dataRow, dataCol) {\n        dataRow = grid.virtual.row.clamp(grid.data.row.toVirtual(dataRow));\n        dataCol = grid.virtual.col.clamp(grid.data.col.toVirtual(dataCol));\n        var newRow = getScrollToRowOrCol(dataRow, 'row', 'height');\n        var newCol = getScrollToRowOrCol(dataCol, 'col', 'width');\n        model.scrollTo(newRow, newCol);\n    };\n\n\n    return model;\n};",
    "module.exports = function (_grid) {\n    var grid = _grid;\n\n    var api = require('../abstract-row-col-model')(grid, 'col', 'width', 100);\n\n    return api;\n};",
    "var elementClass = require('element-class');\nvar util = require('../util');\nvar ctrlOrCmd = require('../ctrl-or-cmd');\nvar key = require('key');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n\n    var api = {\n        annotateDecorator: makeReorderDecorator\n    };\n\n    function makeReorderDecorator(headerDecorator) {\n\n        var wasSelectedAtMousedown = false;\n        headerDecorator._onMousedown = function(e) {\n            wasSelectedAtMousedown = grid.data.col.get(e.col).selected;\n            if (wasSelectedAtMousedown && !ctrlOrCmd(e)) {\n                grid.eventLoop.stopBubbling(e);\n            }\n        }\n\n\n        headerDecorator._onDragStart = function(e) {\n\n            if (e.realCol < grid.colModel.numFixed() || !wasSelectedAtMousedown) {\n                return;\n            }\n\n            var colDescriptor = grid.view.col.get(e.realCol);\n            if (!colDescriptor || colDescriptor.selectable === false) {\n                return;\n            }\n            if (e.enableAutoScroll) {\n                e.enableAutoScroll();\n            }\n            // we want to be the only draggers\n            grid.eventLoop.stopBubbling(e);\n\n            var startCol = headerDecorator.left;\n\n            // create the target line\n            api._targetCol = grid.decorators.create(0, undefined, Infinity, 1, 'cell', 'real');\n            api._targetCol.postRender = function(div) {\n                div.setAttribute('class', 'grid-reorder-target');\n                api._targetCol._renderedElem = div;\n            };\n            grid.decorators.add(api._targetCol);\n\n            // create a decorator for each selected col\n            var selected = grid.colModel.getSelected();\n            api._dragRects = selected.map(function(dataCol) {\n                var viewCol = grid.data.col.toView(dataCol);\n                var dragRect = grid.decorators.create(0, undefined, Infinity, undefined, 'px', 'real');\n                dragRect.colOffset = e.gridX - api._decorators[viewCol].getDecoratorLeft();\n                dragRect.postRender = function(div) {\n                    div.setAttribute('class', 'grid-drag-rect');\n                };\n                dragRect.width = grid.viewPort.getColWidth(viewCol);\n                return dragRect;\n            });\n\n            grid.decorators.add(api._dragRects);\n\n            headerDecorator._unbindKeyDown = grid.escapeStack && grid.escapeStack.addEscapeHandler(removeDecoratorsAndUnbind);\n\n            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function(e) {\n                api._dragRects.forEach(function(dragRect) {\n                    dragRect.left = util.clamp(e.gridX - dragRect.colOffset, grid.viewPort.getColLeft(grid.colModel.numFixed()), Infinity);\n                });\n                api._targetCol.left = util.clamp(e.realCol, grid.colModel.numFixed(), Infinity);\n                api._targetCol.moveAfter = e.realCol > startCol;\n                if (api._targetCol.moveAfter) {\n                    elementClass(api._targetCol._renderedElem).add('right');\n                } else {\n                    elementClass(api._targetCol._renderedElem).remove('right');\n                }\n\n\n            });\n\n            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function() {\n                var targetCol = api._targetCol.left;\n\n                grid.colModel.move(selected.map(function(dataCol) {\n                    return grid.data.col.toVirtual(dataCol);\n                }), grid.viewPort.toVirtualCol(targetCol), api._targetCol.moveAfter);\n\n                removeDecoratorsAndUnbind();\n            });\n\n            function removeDecoratorsAndUnbind() {\n                var removedDecs = api._dragRects.concat(api._targetCol);\n                grid.decorators.remove(removedDecs);\n                headerDecorator._unbindDrag();\n                headerDecorator._unbindDragEnd();\n                headerDecorator._unbindKeyDown && headerDecorator._unbindKeyDown();\n                return true; // for the escape stack\n            }\n        };\n\n        headerDecorator.postRender = function(div) {\n            div.setAttribute('class', 'grid-col-reorder');\n            grid.eventLoop.bind('grid-drag-start', div, headerDecorator._onDragStart);\n            grid.eventLoop.bind('mousedown', div, headerDecorator._onMousedown);\n        };\n\n        return headerDecorator;\n    }\n\n    require('../header-decorators')(grid, api);\n\n    return api;\n};",
    "var key = require('key');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n\n    var api = {\n        annotateDecorator: annotateDecorator\n    };\n\n    function annotateDecorator(headerDecorator) {\n        var col = headerDecorator.left;\n        headerDecorator._dragLine = grid.decorators.create(0, undefined, Infinity, 1, 'px', 'real');\n\n        headerDecorator._dragLine.postRender = function(div) {\n            div.setAttribute('class', 'grid-drag-line');\n        };\n\n        headerDecorator._onMousedown = function(e) {\n            //prevent mousedowns from getting to selection if they hit the dragline\n            grid.eventLoop.stopBubbling(e);\n        };\n\n        headerDecorator._onDragStart = function(e) {\n\n            grid.eventLoop.stopBubbling(e);\n\n            grid.decorators.add(headerDecorator._dragLine);\n\n            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function(e) {\n                var minX = headerDecorator.getDecoratorLeft() + 10;\n                headerDecorator._dragLine.left = Math.max(e.gridX, minX);\n            });\n\n            headerDecorator._unbindKeyDown = grid.escapeStack && grid.escapeStack.addEscapeHandler(removeDecoratorsAndUnbind);\n\n            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function(e) {\n                var newWidth = headerDecorator._dragLine.left - headerDecorator.getDecoratorLeft();\n                grid.view.col.get(col).width = newWidth;\n                grid.colModel.getSelected().forEach(function(dataIdx) {\n                    grid.data.col.get(dataIdx).width = newWidth;\n                });\n                removeDecoratorsAndUnbind();\n            });\n\n            function removeDecoratorsAndUnbind() {\n                grid.decorators.remove(headerDecorator._dragLine);\n                headerDecorator._unbindDrag();\n                headerDecorator._unbindDragEnd();\n                headerDecorator._unbindKeyDown && headerDecorator._unbindKeyDown();\n                return true; // for the escape stack\n            }\n        };\n\n        headerDecorator.postRender = function(div) {\n            div.style.transform = 'translateX(50%)';\n            div.style.webkitTransform = 'translateX(50%)';\n\n            div.style.removeProperty('left');\n            div.setAttribute('class', 'col-resize');\n            div.setAttribute('dts', 'grid_header_resize');\n\n            grid.eventLoop.bind('grid-drag-start', div, headerDecorator._onDragStart);\n            grid.eventLoop.bind('mousedown', div, headerDecorator._onMousedown);\n        };\n    }\n\n    require('../header-decorators')(grid, api);\n\n    return api;\n};",
    "var tsv = require('../tsv');\nvar debounce = require('../debounce');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n    var model = {};\n\n    function getCopyPasteRange() {\n        var selectionRange = grid.navigationModel.selection;\n        //valid selection range cannot go to -1\n        if (selectionRange.top === -1) {\n            selectionRange = {\n                top: grid.navigationModel.focus.row,\n                left: grid.navigationModel.focus.col,\n                width: 1,\n                height: 1\n            };\n        }\n        return selectionRange;\n    }\n\n    grid.eventLoop.bind('copy', function(e) {\n        if (!grid.focused) {\n            if (e.target === grid.textarea) {\n                e.preventDefault();\n            }\n            return;\n        }\n        // prepare for copy\n        var copyTable = document.createElement('table');\n        var tableBody = document.createElement('tbody');\n        copyTable.appendChild(tableBody);\n        var tsvData = [];\n        var selectionRange = getCopyPasteRange();\n        var gotNull = false;\n        grid.data.iterate(selectionRange, function() {\n            var row = document.createElement('tr');\n            tableBody.appendChild(row);\n            var array = [];\n            tsvData.push(array);\n            return {\n                row: row,\n                array: array\n            };\n        }, function(r, c, rowResult) {\n            var data = grid.dataModel.getCopyData(r, c);\n\n            // intentional == checks null or undefined\n            if (data == null) {\n                return gotNull = true; // this breaks the col loop\n            }\n            var td = document.createElement('td');\n            td.innerHTML = data || ' ';\n            rowResult.row.appendChild(td);\n            rowResult.array.push(td.textContent);\n        });\n        if (!gotNull) {\n            e.clipboardData.setData('text/plain', tsv.stringify(tsvData));\n            e.clipboardData.setData('text/html', copyTable.outerHTML);\n            e.preventDefault();\n            setTimeout(function() {\n                grid.eventLoop.fire('grid-copy');\n            }, 1);\n        }\n    });\n\n    grid.eventLoop.bind('paste', function(e) {\n        if (!grid.focused) {\n            return;\n        }\n        var selectionRange = getCopyPasteRange();\n        if (!e.clipboardData || !e.clipboardData.getData) {\n            console.warn('no clipboard data on paste event');\n            return;\n        }\n        var pasteData = tsv.parse(e.clipboardData.getData('text/plain'));\n        var pasteHtml = e.clipboardData.getData('text/html');\n        e.preventDefault();\n\n        setTimeout(function() {\n            var tempDiv = document.createElement('div');\n            tempDiv.innerHTML = pasteHtml;\n            if (tempDiv.querySelector('table')) {\n                pasteData = [];\n                [].forEach.call(tempDiv.querySelectorAll('tr'), function(tr) {\n                    var row = [];\n                    pasteData.push(row);\n                    [].forEach.call(tr.querySelectorAll('td'), function(td) {\n                        row.push(td.innerHTML);\n                    });\n                });\n            }\n            var dataChanges = [];\n            var singlePasteValue;\n            if (pasteData.length === 1 && pasteData[0].length === 1) {\n                singlePasteValue = pasteData[0][0];\n            }\n\n            if (singlePasteValue) {\n                // this will do nothing if no other selections as it will be an empty array\n                var ranges = [selectionRange];\n                ranges = ranges.concat(grid.navigationModel.otherSelections);\n                ranges.forEach(function(range) {\n                    grid.data.iterate(range, function(r, c) {\n                        var pasteValue = singlePasteValue;\n                        dataChanges.push({\n                            row: r,\n                            col: c,\n                            data: pasteValue && pasteValue.trim(),\n                            paste: true\n                        });\n                    });\n                });\n            } else {\n                var top = selectionRange.top;\n                var left = selectionRange.left;\n\n\n                pasteData.forEach(function(row, r) {\n                    var dataRow = r + top;\n                    if (dataRow > grid.data.row.count() - 1) {\n                        return;\n                    }\n                    row.forEach(function(pasteValue, c) {\n                        var dataCol = c + left;\n                        //intention == to match null and undefined\n                        if (pasteValue == undefined || dataCol > grid.data.col.count() - 1) {\n                            return;\n                        }\n                        dataChanges.push({\n                            row: dataRow,\n                            col: dataCol,\n                            data: pasteValue && pasteValue.trim(),\n                            paste: true\n                        });\n                    });\n                });\n                var newSelection = {\n                    top: top,\n                    left: left,\n                    height: pasteData.length,\n                    width: pasteData[0].length\n                };\n\n                grid.navigationModel.clearSelection()\n                grid.navigationModel.setSelection(newSelection)\n            }\n\n\n            grid.dataModel.set(dataChanges);\n        }, 1);\n    });\n\n    var maybeSelectText = debounce(function maybeSelectTextInner() {\n        if ((!model.isSelectionDisabled || !model.isSelectionDisabled()) && grid.focused) {\n            grid.textarea.value = grid.dataModel.get(grid.navigationModel.focus.row, grid.navigationModel.focus.col).formatted || '.';\n            grid.textarea.select();\n        }\n    }, 1)\n\n    model._maybeSelectText = maybeSelectText;\n\n    grid.eventLoop.bind('keyup', function(e) {\n        maybeSelectText();\n    });\n    grid.eventLoop.bind('grid-focus', function(e) {\n        maybeSelectText();\n    });\n    grid.eventLoop.bind('mousedown', function(e) {\n        if (e.target !== grid.textarea) {\n            return;\n        }\n        maybeSelectText();\n    });\n    return model;\n};",
    "var elementClass = require('element-class');\nvar dirtyClean = require('../dirty-clean');\nvar util = require('../util');\nvar rangeUtil = require('../range-util');\nvar passThrough = require('../pass-through');\nvar capitalize = require('capitalize');\n\nmodule.exports = function(opts) {\n    function GridMarker() {\n\n    }\n    var grid = new GridMarker();\n\n    // the order here matters because some of these depend on each other\n    grid.eventLoop = require('../event-loop')(grid);\n    grid.decorators = require('../decorators')(grid);\n    grid.cellClasses = require('../cell-classes')(grid);\n    grid.rowModel = require('../row-model')(grid);\n    grid.colModel = require('../col-model')(grid);\n    grid.dataModel = require('../simple-data-model')(grid);\n    grid.virtualPixelCellModel = require('../virtual-pixel-cell-model')(grid);\n    grid.cellScrollModel = require('../cell-scroll-model')(grid);\n    grid.cellMouseModel = require('../cell-mouse-model')(grid);\n\n    grid.viewPort = require('../view-port')(grid);\n\n    addUtilsToCore(); // this has to happen here for things not to break, view layer will add cell classes and that cache requires the utils\n\n\n    grid.viewLayer = require('../view-layer')(grid);\n\n    // things with logic that also register decorators (slightly less core than the other models)\n    grid.navigationModel = require('../navigation-model')(grid);\n    grid.pixelScrollModel = require('../pixel-scroll-model')(grid);\n    grid.colResize = require('../col-resize')(grid);\n    if (!(opts && opts.col && opts.col.disableReorder)) {\n        grid.colReorder = require('../col-reorder')(grid);\n    }\n    grid.showHiddenCols = require('../show-hidden-cols')(grid);\n    grid.copyPaste = require('../copy-paste')(grid);\n\n    var drawRequested = false;\n    grid.requestDraw = function() {\n        if (!grid.eventLoop.isRunning) {\n            grid.viewLayer.draw();\n        } else {\n            drawRequested = true;\n        }\n    };\n\n    grid.eventLoop.bind('grid-draw', function() {\n        drawRequested = false;\n    });\n\n    grid.eventLoop.addExitListener(function() {\n        if (drawRequested) {\n            grid.viewLayer.draw();\n        }\n    });\n\n    function setupTextareaForContainer(textarea, container) {\n        textarea.addEventListener('focus', function() {\n            if (container) {\n                elementClass(container).add('focus');\n            }\n            textarea.select();\n            grid.focused = true;\n            grid.eventLoop.fire('grid-focus');\n        });\n\n        textarea.addEventListener('blur', function() {\n            if (container) {\n                elementClass(container).remove('focus');\n            }\n            grid.focused = false;\n            grid.eventLoop.fire('grid-blur');\n        });\n\n        var widthResetTimeout;\n        grid.eventLoop.addInterceptor(function(e) {\n            if (e.type !== 'mousedown' || e.button !== 2) {\n                return;\n            }\n            textarea.style.width = '100%';\n            textarea.style.height = '100%';\n            textarea.style.zIndex = 1;\n            clearTimeout(widthResetTimeout);\n            widthResetTimeout = setTimeout(function() {\n                textarea.style.zIndex = 0;\n                textarea.style.width = '0px';\n                textarea.style.height = '1px';\n            }, 1);\n        });\n\n        container.appendChild(textarea);\n        if (!container.getAttribute('tabIndex')) {\n            container.tabIndex = -1;\n        }\n        container.addEventListener('focus', function() {\n            if (textarea) {\n                textarea.focus();\n            }\n        });\n    }\n\n\n    function createFocusTextArea() {\n        var textarea = document.createElement('textarea');\n        textarea.setAttribute('dts', 'grid-textarea');\n        util.position(textarea, 0, 0);\n        textarea.style.width = '0px';\n        textarea.style.height = '1px';\n        textarea.style.maxWidth = '100%';\n        textarea.style.maxHeight = '100%';\n        textarea.style.zIndex = 0;\n        textarea.style.overflow = 'hidden';\n\n        textarea.style.background = 'transparent';\n        textarea.style.color = 'transparent';\n        textarea.style.border = 'none';\n        textarea.style.boxShadow = 'none';\n        textarea.style.cursor = 'default';\n        textarea.classList.add('grid-textarea');\n        textarea.setAttribute('ondragstart', 'return false;');\n\n        return textarea;\n    }\n\n    function addUtilsToCore() {\n        function iterateRange() {\n            // expects to be called with the space as its this\n            var args = rangeUtil.getArgs(arguments);\n            var range = args.range;\n            var rowFn = args.rowFn;\n            var cellFn = args.cellFn;\n            var rowResult;\n            rowloop: for (var r = range.top; r < range.top + range.height; r = this.row.next(r)) {\n                rowResult = undefined;\n                if (rowFn) {\n                    rowResult = rowFn(r);\n                }\n                colloop: for (var c = range.left; c < range.left + range.width; c = this.col.next(c)) {\n                    if (cellFn) {\n                        var result = cellFn(r, c, rowResult);\n                        if (result === false) {\n                            break rowloop;\n                        } else if (result === true) {\n                            break colloop;\n                        }\n                    }\n                }\n            }\n        }\n\n        function iterateWhileHidden(step, start) {\n            step = step || 1;\n            for (var i = start + step; i < this.count() && i >= 0; i += step) {\n                if (!this.get(i).hidden) {\n                    return i;\n                }\n            }\n        }\n\n        function addToDimension(dim, spaceName, getter) {\n            //convert whatever space to virtual and use the row or col virtual getter\n            dim.get = function(idx) {\n                return getter(this.toVirtual(idx));\n            }.bind(dim);\n            dim.next = iterateWhileHidden.bind(dim, 1);\n            dim.prev = iterateWhileHidden.bind(dim, -1);\n            dim.clamp = function(idx) {\n                return util.clamp(idx, 0, this.count() - 1);\n            }.bind(dim);\n            dim.indexes = function() {\n                var opts;\n                opts = arguments[0];\n                opts = opts || {};\n                opts.from = opts.from || 0;\n                var count = this.count();\n                opts.to = opts.to + 1 || (opts.length && opts.length + opts.from) || count;\n                var indexes = [];\n                for (var idx = Math.max(opts.from, 0); idx < Math.min(opts.to, count); idx = opts.reverse ? this.prev(idx) : this.next(idx)) {\n                    indexes.push(idx);\n                }\n                return indexes;\n            };\n\n            dim.iterate = function() {\n                var opts;\n                var fn;\n                if (arguments.length === 2) {\n                    opts = arguments[0];\n                    fn = arguments[1];\n                } else {\n                    fn = arguments[0];\n                }\n                dim.indexes(opts).some(function(idx) {\n                    return fn(idx);\n                });\n            };\n\n            // have data to data be passthrough for example\n            dim['to' + capitalize(spaceName)] = passThrough;\n\n            return dim;\n        }\n\n        function addToSpace(spaceName) {\n            var space = grid[spaceName];\n            space.iterate = iterateRange.bind(space);\n            addToDimension(space.col, spaceName, function(idx) {\n                return grid.colModel.get(idx);\n            });\n            addToDimension(space.row, spaceName, function(idx) {\n                return grid.rowModel.get(idx);\n            });\n            space.up = space.row.prev;\n            space.down = space.row.next;\n            space.left = space.col.prev;\n            space.right = space.col.next;\n        }\n\n\n        grid.data = {\n            col: {\n                toVirtual: function(dataCol) {\n                    return grid.colModel.toVirtual(dataCol);\n                },\n                toView: function(dataCol) {\n                    return grid.virtual.col.toView(this.toVirtual(dataCol));\n                },\n                count: function() {\n                    return grid.colModel.length();\n                }\n            },\n            row: {\n                toVirtual: function(dataRow) {\n                    return grid.rowModel.toVirtual(dataRow);\n                },\n                toView: function(dataRow) {\n                    return grid.virtual.row.toView(this.toVirtual(dataRow));\n                },\n                count: function() {\n                    return grid.rowModel.length();\n                }\n            }\n        };\n        addToSpace('data');\n\n        grid.virtual = {\n            col: {\n                toData: function(virtualCol) {\n                    return grid.colModel.toData(virtualCol);\n                },\n                toView: function(virtualCol) {\n                    return grid.viewPort.toRealCol(virtualCol);\n                },\n                count: function() {\n                    return grid.colModel.length(true);\n                }\n            },\n            row: {\n                toData: function(virtualRow) {\n                    return grid.rowModel.toData(virtualRow);\n                },\n                toView: function(virtualRow) {\n                    return grid.viewPort.toRealRow(virtualRow);\n                },\n                count: function() {\n                    return grid.rowModel.length(true);\n                }\n            }\n        };\n        addToSpace('virtual');\n\n        grid.view = {\n            col: {\n                toData: function(viewCol) {\n                    return grid.virtual.col.toData(this.toVirtual(viewCol));\n                },\n                toVirtual: function(viewCol) {\n                    return grid.viewPort.toVirtualCol(viewCol);\n                },\n                count: function() {\n                    return grid.viewPort.cols;\n                }\n            },\n            row: {\n                toData: function(viewRow) {\n                    return grid.virtual.row.toData(this.toVirtual(viewRow));\n                },\n                toVirtual: function(viewRow) {\n                    return grid.viewPort.toVirtualRow(viewRow);\n                },\n                count: function() {\n                    return grid.viewPort.rows;\n                }\n            }\n        };\n        addToSpace('view');\n\n        timeouts = [];\n        grid.timeout = function() {\n            var id = setTimeout.apply(window, arguments);\n            timeouts.push(id);\n            return id;\n        };\n        intervals = [];\n        grid.interval = function() {\n            var id = setInterval.apply(window, arguments);\n            intervals.push(id);\n            return id;\n        };\n    }\n\n    var intervals;\n    var timeouts;\n    grid.eventLoop.bind('grid-destroy', function() {\n        intervals.forEach(function(id) {\n            clearInterval(id);\n        });\n\n        timeouts.forEach(function(id) {\n            clearTimeout(id);\n        });\n    });\n\n    grid.build = function(container) {\n        grid.container = container;\n        setupTextareaForContainer(grid.textarea, container);\n        grid.viewPort.sizeToContainer(container);\n        grid.viewLayer.build(container);\n        grid.eventLoop.setContainer(container);\n        container.style.overflow = 'hidden';\n        // the container should never actually scroll, but the browser does automatically sometimes so let's reset it when that happens\n        container.addEventListener('scroll', function() {\n            container.scrollTop = 0;\n            container.scrollLeft = 0;\n        });\n    };\n\n    grid.makeDirtyClean = function() {\n        return dirtyClean(grid);\n    };\n\n    grid.eventIsOnCells = function(e) {\n        var target = e.target;\n        return target && (target.classList &&\n                (target.classList.contains('grid-col-reorder') ||\n                    target.classList.contains('grid-cell')\n                )) ||\n            target === grid.textarea;\n    }\n\n    grid.textarea = createFocusTextArea();\n\n    grid.destroy = function() {\n        grid.eventLoop.fire('grid-destroy');\n    };\n\n    return grid;\n};",
    "module.exports = function (e) {\n    return (window.navigator.userAgent.match(/win/i) ? e.ctrlKey : e.metaKey)\n};",
    "module.exports = function (name, bubbles, cancelable, detail) {\n    var event = document.createEvent('CustomEvent');  // MUST be 'CustomEvent'\n    event.initCustomEvent(name, bubbles, cancelable, detail);\n    return event;\n};",
    "module.exports = function(fn, delay) {\n    var f = function debounced() {\n        if (f.timeout) {\n            clearTimeout(f.timeout);\n            f.timeout = undefined;\n        }\n        if (!f.canceled) {\n            f.timeout = setTimeout(fn, delay);\n        }\n        f.cancel = function() {\n            clearTimeout(f.timeout);\n            f.timeout = undefined;\n            f.canceled = true;\n        };\n    };\n    return f;\n};",
    "var util = require('../util');\nvar makeDirtyClean = require('../dirty-clean');\nvar positionRange = require('../position-range');\n\nmodule.exports = function (_grid) {\n    var grid = _grid;\n\n    var dirtyClean = makeDirtyClean(grid);\n\n    var aliveDecorators = [];\n    var deadDecorators = [];\n\n    var decorators = {\n        add: function (decorators) {\n            if (!util.isArray(decorators)) {\n                decorators = [decorators];\n            }\n            decorators.forEach(function (decorator) {\n                aliveDecorators.push(decorator);\n            });\n            dirtyClean.setDirty();\n        },\n        remove: function (decorators) {\n            if (!util.isArray(decorators)) {\n                decorators = [decorators];\n            }\n            decorators.forEach(function (decorator) {\n                var index = aliveDecorators.indexOf(decorator);\n                if (index !== -1) {\n                    aliveDecorators.splice(index, 1);\n                    deadDecorators.push(decorator);\n                    dirtyClean.setDirty();\n                }\n            });\n        },\n        getAlive: function () {\n            return aliveDecorators.slice(0);\n        },\n        popAllDead: function () {\n            var oldDead = deadDecorators;\n            deadDecorators = [];\n            return oldDead;\n        },\n        isDirty: dirtyClean.isDirty,\n        create: function (t, l, h, w, u, s) {\n            var decorator = {};\n            var thisDirtyClean = makeDirtyClean(grid);\n\n            //mixin the position range functionality\n            positionRange(decorator, thisDirtyClean, dirtyClean);\n            decorator.top = t;\n            decorator.left = l;\n            decorator.height = h;\n            decorator.width = w;\n            decorator.units = u || decorator.units;\n            decorator.space = s || decorator.space;\n\n            //they can override but we should have an empty default to prevent npes\n            decorator.render = function () {\n                var div = document.createElement('div');\n                div.style.position = 'absolute';\n                div.style.top = '0px';\n                div.style.left = '0px';\n                div.style.bottom = '0px';\n                div.style.right = '0px';\n                if (decorator.postRender) {\n                    decorator.postRender(div);\n                }\n                return div;\n            };\n            return decorator;\n\n        }\n\n    };\n\n\n    return decorators;\n};",
    "module.exports = function(_grid) {\n    var grid = _grid;\n    var dirty = true;\n\n    grid.eventLoop.bind('grid-draw', function() {\n        api.setClean();\n    });\n\n\n    var api = {\n        isDirty: function() {\n            return dirty;\n        },\n        isClean: function() {\n            return !dirty;\n        },\n        setDirty: function() {\n            dirty = true;\n            // when things are initalizing sometimes this doesn't exist yet\n            // we have to hope that at the end of initialization the grid will call request draw itself\n            if (grid.requestDraw) {\n                grid.requestDraw();\n            }\n        },\n        setClean: function() {\n            dirty = false;\n        }\n    };\n    return api;\n};",
    "var mousewheel = require('../mousewheel');\nvar util = require('../util');\nvar listeners = require('../listeners');\n\nvar EVENTS = ['click', 'mousedown', 'mouseup', 'mousemove', 'dblclick', 'keydown', 'keypress', 'keyup', 'copy', 'paste'];\n\nvar GRID_EVENTS = ['grid-drag-start', 'grid-drag', 'grid-cell-drag', 'grid-drag-end', 'grid-cell-mouse-move'];\n\nvar eventLoop = function(_grid) {\n    var grid = _grid;\n    var eloop = {\n        isRunning: false\n    };\n\n    var handlersByName = {};\n    var domUnbindFns = [];\n\n    var unbindAll;\n\n    eloop.setContainer = function(container) {\n        var unbindMouseWheelFn = mousewheel.bind(container, mainLoop);\n\n        EVENTS.forEach(function(name) {\n            bindToDomElement(container, name, mainLoop);\n        });\n\n        GRID_EVENTS.forEach(function(name) {\n            bindToDomElement(window, name, mainLoop);\n        });\n\n        unbindAll = function() {\n            unbindMouseWheelFn();\n\n            // have to copy the array since the unbind will actually remove itself from the array which modifies it mid iteration\n            domUnbindFns.slice(0).forEach(function(unbind) {\n                unbind();\n            });\n\n            Object.keys(handlersByName).forEach(function(key) {\n                handlersByName[key] = [];\n            });\n        };\n    };\n\n    function getHandlers(name) {\n        var handlers = handlersByName[name];\n        if (!handlers) {\n            handlers = handlersByName[name] = [];\n        }\n        return handlers;\n    }\n\n    function bindToDomElement(elem, name, listener) {\n        elem.addEventListener(name, listener);\n        var unbindFn = function() {\n            elem.removeEventListener(name, listener);\n            domUnbindFns.splice(domUnbindFns.indexOf(unbindFn), 1);\n        };\n        domUnbindFns.push(unbindFn);\n        return unbindFn;\n    }\n\n    function getHandlerFromArgs(args) {\n        var handler = args.filter(function(arg) {\n            return typeof arg === 'function';\n        })[0];\n        return handler;\n    }\n\n    eloop.bind = function() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        var name = args.filter(function(arg) {\n            return typeof arg === 'string';\n        })[0];\n        var handler = getHandlerFromArgs(args);\n        if (!handler || !name) {\n            throw 'cannot bind without at least name and function';\n        }\n\n\n        var elem = args.filter(function(arg) {\n            return util.isElement(arg) || arg === window || arg === document;\n        })[0];\n\n        if (!elem) {\n            getHandlers(name).push(handler);\n            return function() {\n                var handlers = getHandlers(name);\n                handlers.splice(handlers.indexOf(handler), 1);\n            };\n        } else {\n            var listener = loopWith(handler);\n            // make sure the elem can receive events\n            if (elem.style) {\n                elem.style.pointerEvents = 'auto';\n            }\n            return bindToDomElement(elem, name, listener);\n        }\n    };\n\n    eloop.bindOnce = function() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        var handler = getHandlerFromArgs(args);\n        args.splice(args.indexOf(handler), 1, function bindOnceHandler(e) {\n            unbind();\n            handler(e);\n        });\n        var unbind = eloop.bind.apply(this, args);\n        return unbind;\n    }\n\n    eloop.fire = function(event) {\n        event = typeof event === 'string' ? {\n            type: event\n        } : event;\n        mainLoop(event);\n    };\n\n    var interceptors = listeners();\n    var exitListeners = listeners();\n\n    eloop.addInterceptor = interceptors.addListener;\n    eloop.addExitListener = exitListeners.addListener;\n\n    function loopWith(fn) {\n        return function(e) {\n            loop(e, fn);\n        };\n    }\n\n    var mainLoop = loopWith(function(e) {\n        // have to copy the array because handlers can unbind themselves which modifies the array\n        // we use some so that we can break out of the loop if need be\n        getHandlers(e.type).slice(0).some(function(handler) {\n            handler(e);\n            if (e.gridStopBubbling) {\n                return true;\n            }\n        });\n    });\n\n    function loop(e, bodyFn) {\n        if (eloop.logTargets) {\n            console.log('target', e.target, 'currentTarget', e.currentTarget);\n        }\n        var isOuterLoopRunning = eloop.isRunning;\n        eloop.isRunning = true;\n        interceptors.notify(e);\n        if (!e.gridStopBubbling) {\n            bodyFn(e);\n        }\n\n        if (!isOuterLoopRunning) {\n            eloop.isRunning = false;\n            exitListeners.notify(e);\n        }\n    }\n\n    eloop.bind('grid-destroy', function() {\n        unbindAll();\n        eloop.destroyed = true;\n    });\n\n    eloop.stopBubbling = function(e) {\n        e.gridStopBubbling = true;\n        return e;\n    };\n\n    return eloop;\n};\n\n\neventLoop.EVENTS = EVENTS;\neventLoop.GRID_EVENTS = GRID_EVENTS;\nmodule.exports = eventLoop;",
    "var moduleName = 'grid';\nmodule.exports = moduleName;\n\nangular.module(moduleName, [\n    require('./angular-decorator'),\n    require('./angular-builder')\n])\n\n.factory('GridSrvc', function() {\n    return {\n        core: require('./core')\n    };\n});",
    "module.exports = function (_grid, model) {\n    var grid = _grid;\n\n    var api = model || {};\n    api._decorators = {};\n\n    function makeDecorator(col) {\n        var decorator = grid.decorators.create(0, col, 1, 1, 'cell', 'real');\n\n\n        decorator.getDecoratorLeft = function () {\n            var firstRect = decorator.boundingBox && decorator.boundingBox.getClientRects() && decorator.boundingBox.getClientRects()[0] || {};\n            return grid.viewPort.toGridX(firstRect.left) || 0;\n        };\n\n        if (api.annotateDecorator) {\n            api.annotateDecorator(decorator);\n        }\n\n\n        return decorator;\n    }\n\n    api.makeDecorator = api.makeDecorator || makeDecorator;\n\n    function ensureDecoratorPerCol() {\n        for (var c = 0; c < grid.viewPort.cols; c++) {\n            if (!api._decorators[c]) {\n                if (api.isNeeded && !api.isNeeded(c)) {\n                    continue;\n                }\n                var decorator = api.makeDecorator(c);\n                api._decorators[c] = decorator;\n                grid.decorators.add(decorator);\n            }\n        }\n    }\n\n    grid.eventLoop.bind('grid-viewport-change', function () {\n        ensureDecoratorPerCol();\n    });\n    ensureDecoratorPerCol();\n\n    return api;\n};",
    "/*\n A simple package for creating a list of listeners that can be added to and notified\n */\n\nmodule.exports = function () {\n    var listeners = [];\n    return {\n        //returns a removal function to unbind the listener\n        addListener: function (fn) {\n            listeners.push(fn);\n            return function () {\n                listeners.splice(listeners.indexOf(fn), 1);\n            };\n        },\n        notify: function (e) {\n            listeners.forEach(function (listener) {\n                listener(e);\n            });\n        }\n    };\n};",
    "var EVENT_NAMES = ['mousewheel', 'wheel', 'DOMMouseScroll'];\n\nvar api = {\n    getDelta: function(event, xaxis) {\n        if (event.wheelDelta) { //for everything but firefox\n            var delta = event.wheelDeltaY;\n            if (xaxis) {\n                delta = event.wheelDeltaX;\n            }\n            return delta;\n\n        } else if (event.detail) { //for firefox pre version 17\n            if (event.axis && ((event.axis === 1 && xaxis) || (event.axis === 2 && !xaxis))) {\n                return -1 * event.detail * 12;\n            }\n        } else if (event.deltaX || event.deltaY) {\n            if (xaxis) {\n                return -1 * event.deltaX;\n            } else {\n                return -1 * event.deltaY;\n            }\n        }\n        return 0;\n    },\n\n    //binds a cross browser normalized mousewheel event, and returns a function that will unbind the listener;\n    bind: function(elem, listener) {\n        var normalizedListener = function(e) {\n            listener(normalizeWheelEvent(e));\n        };\n\n        EVENT_NAMES.forEach(function(name) {\n            elem.addEventListener(name, normalizedListener);\n        });\n\n        return function() {\n            EVENT_NAMES.forEach(function(name) {\n                elem.removeEventListener(name, normalizedListener);\n            });\n        };\n\n    },\n    normalize: normalizeWheelEvent\n};\n\nfunction normalizeWheelEvent(e) {\n    var deltaX = api.getDelta(e, true);\n    var deltaY = api.getDelta(e);\n    var newEvent = Object.create(e, {\n        deltaY: {\n            value: deltaY\n        },\n        deltaX: {\n            value: deltaX\n        },\n        type: {\n            value: 'mousewheel'\n        },\n        target: {\n            value: e.target\n        },\n        currentTarget: {\n            value: e.currentTarget\n        }\n    });\n\n    newEvent.preventDefault = function() {\n        newEvent.defaultPrevented = true;\n        if (e && e.preventDefault) {\n            e.preventDefault();\n        }\n    };\n    return newEvent;\n}\n\nmodule.exports = api;",
    "var key = require('key');\nvar arrow = key.code.arrow;\nvar util = require('../util');\nvar rangeUtil = require('../range-util');\nvar ctrlOrCmd = require('../ctrl-or-cmd');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n\n    var model = {\n        focus: {\n            row: 0,\n            col: 0\n        },\n        checkboxModeFor: {}\n    };\n\n    model.otherSelections = [];\n\n    var focusClass = grid.cellClasses.create(0, 0, 'focus');\n    grid.cellClasses.add(focusClass);\n\n    model.focusDecorator = grid.decorators.create(0, 0, 1, 1);\n    var focusDefaultRender = model.focusDecorator.render;\n    model.focusDecorator.render = function() {\n        var div = focusDefaultRender();\n        div.setAttribute('class', 'grid-focus-decorator');\n        return div;\n    };\n    grid.decorators.add(model.focusDecorator);\n\n    model.setFocus = function setFocus(row, col, dontClearSelection, dontSetSelection) {\n        row = grid.data.row.clamp(row);\n        if (typeof row !== 'number' || isNaN(row)) {\n            row = model.focus.row;\n        }\n        col = grid.data.col.clamp(col);\n        if (typeof col !== 'number' || isNaN(col)) {\n            col = model.focus.col;\n        }\n        var changed = row !== model.focus.row || col !== model.focus.col;\n        model.focus.row = row;\n        model.focus.col = col;\n        focusClass.top = row;\n        focusClass.left = col;\n        model.focusDecorator.top = row;\n        model.focusDecorator.left = col;\n        grid.cellScrollModel.scrollIntoView(row, col);\n        if (!dontClearSelection) {\n            clearOtherSelections();\n        }\n        if (!dontSetSelection) {\n            setSelectionToFocus();\n        }\n        if (changed) {\n            grid.eventLoop.fire('grid-focus-change');\n        }\n    };\n\n    function seekNextEdge(newIndex, startedDefined, isForwardEdge, isBackwardEdge, goForward) {\n\n        var isEdgeToSeek;\n        if (isForwardEdge(newIndex) || !startedDefined) {\n            isEdgeToSeek = isBackwardEdge;\n        } else {\n            isEdgeToSeek = isForwardEdge;\n        }\n\n\n        while (goForward(newIndex) !== undefined && !isEdgeToSeek(newIndex = goForward(newIndex))) /*eslint-disable no-empty*/ {\n            // empty\n        } /*eslint-enable no-empty*/\n\n        return newIndex;\n    }\n\n    function navFrom(row, col, e) {\n        // if nothing changes great we'll stay where we are\n        var newRow = row;\n        var newCol = col;\n        var isSeek = ctrlOrCmd(e);\n        var isLeftwardEdge, isRightwardEdge, isUpwardEdge, isDownwardEdge, cellHasValue, startedDefined;\n        if (isSeek) {\n            cellHasValue = function(r, c) {\n                if (r === undefined || c === undefined) {\n                    return false;\n                }\n\n                return !!grid.dataModel.get(r, c).formatted;\n            };\n            isLeftwardEdge = function(c) {\n                return cellHasValue(newRow, c) && !cellHasValue(newRow, grid.data.left(c));\n            };\n            isRightwardEdge = function(c) {\n                return cellHasValue(newRow, c) && !cellHasValue(newRow, grid.data.right(c));\n            };\n            isUpwardEdge = function(r) {\n                return cellHasValue(r, newCol) && !cellHasValue(grid.data.up(r), newCol);\n            };\n            isDownwardEdge = function(r) {\n                return cellHasValue(r, newCol) && !cellHasValue(grid.data.down(r), newCol);\n            };\n            startedDefined = cellHasValue(newRow, newCol);\n        }\n        switch (e.which) {\n            case arrow.down.code:\n                if (isSeek) {\n                    newRow = seekNextEdge(newRow, startedDefined, isDownwardEdge, isUpwardEdge, grid.data.down);\n                } else {\n                    newRow = grid.data.down(newRow);\n                }\n                break;\n            case arrow.up.code:\n                if (isSeek) {\n                    newRow = seekNextEdge(newRow, startedDefined, isUpwardEdge, isDownwardEdge, grid.data.up);\n                } else {\n                    newRow = grid.data.up(newRow);\n                }\n                break;\n            case arrow.right.code:\n                if (isSeek) {\n                    newCol = seekNextEdge(newCol, startedDefined, isRightwardEdge, isLeftwardEdge, grid.data.right);\n                } else {\n                    newCol = grid.data.right(newCol);\n                }\n                break;\n            case arrow.left.code:\n                if (isSeek) {\n                    newCol = seekNextEdge(newCol, startedDefined, isLeftwardEdge, isRightwardEdge, grid.data.left);\n                } else {\n                    newCol = grid.data.left(newCol);\n                }\n                break;\n        }\n        if (newRow === undefined) {\n            newRow = row;\n        }\n        if (newCol === undefined) {\n            newCol = col;\n        }\n        return {\n            row: newRow,\n            col: newCol\n        };\n    }\n\n    model._navFrom = navFrom;\n\n    model.handleTabEvent = function(e) {\n        var newCol = model.focus.col;\n        var newRow = model.focus.row;\n        if (!e || !e.shiftKey) {\n            if (newCol === grid.data.col.count() - 1) {\n                newRow = grid.data.down(newRow);\n                newCol = 0;\n            } else {\n                newCol = grid.data.right(newCol);\n            }\n        } else {\n            if (newCol === 0) {\n                newRow = grid.data.up(newRow);\n                newCol = grid.data.col.count() - 1;\n            } else {\n                newCol = grid.data.left(newCol);\n            }\n        }\n        model.setFocus(newRow, newCol);\n        e.preventDefault();\n    }\n\n    grid.eventLoop.bind('keydown', function(e) {\n        if (!grid.focused) {\n            return;\n        }\n        // handle tab\n        if (key.is(key.code.special.tab, e.which)) {\n            model.handleTabEvent(e);\n            return;\n        }\n\n        if (!key.is(arrow, e.which)) {\n            return;\n        }\n        // focus logic\n\n        if (!e.shiftKey) {\n            var newFocus = navFrom(model.focus.row, model.focus.col, e);\n            model.setFocus(newFocus.row, newFocus.col, e);\n        } else {\n            // selection logic\n            var newSelection;\n            // stand in for if it's cleared\n            if (model.selection.top === -1) {\n                newSelection = {\n                    top: model.focus.row,\n                    left: model.focus.col,\n                    height: 1,\n                    width: 1\n                };\n            } else {\n                newSelection = {\n                    top: model.selection.top,\n                    left: model.selection.left,\n                    height: model.selection.height,\n                    width: model.selection.width\n                };\n            }\n            var navFromRow;\n            var navFromCol;\n            if (model.focus.row === newSelection.top) {\n                navFromRow = newSelection.top + newSelection.height - 1;\n            } else {\n                navFromRow = newSelection.top;\n            }\n\n            if (model.focus.col === newSelection.left) {\n                navFromCol = newSelection.left + newSelection.width - 1;\n            } else {\n                navFromCol = newSelection.left;\n            }\n            var newRowCol = navFrom(navFromRow, navFromCol, e);\n            setSelectionFromPoints(model.focus.row, model.focus.col, newRowCol.row, newRowCol.col);\n            grid.cellScrollModel.scrollIntoView(newRowCol.row, newRowCol.col);\n        }\n    });\n\n    function isNavableMouseEvent(e) {\n        var target = e.target;\n        // if there's no target let it through because that only happens in unit tests,\n        // or if it happened in real world it wouldn't have a valid row or col and so wouldn't do anything anyway\n        return !target || grid.eventIsOnCells(e) && e.button !== 2;\n    }\n\n    function isCheckboxModeForRowCol(row, col) {\n        return model.checkboxModeFor.rows && col < 0 || (row < 0 && colSelectable(col)) && model.checkboxModeFor.cols\n    }\n\n    grid.eventLoop.bind('mousedown', function(e) {\n        if (!isNavableMouseEvent(e)) {\n            return;\n        }\n        // assume the event has been annotated by the cell mouse model interceptor\n        var row = e.row;\n        var col = e.col;\n\n        // if we're in checkbox mode pretend the user held command for header mousedowns only \n        var isCheckboxMode = isCheckboxModeForRowCol(row, col);\n        var ctrlOrCmdPressed = isCheckboxMode || ctrlOrCmd(e);\n\n        if (e.shiftKey) {\n            var fromRow = model.focus.row;\n            var fromCol = model.focus.col;\n            var toRow = row;\n            var toCol = col;\n            var wasSelected;\n            if (toRow < 0) {\n                var colDescriptor = grid.data.col.get(toCol);\n                if (colDescriptor.selectable !== false) {\n                    wasSelected = colDescriptor.selected;\n                    fromRow = 0;\n                    toRow = Infinity;\n                }\n\n            }\n            if (toCol < 0) {\n                wasSelected = grid.data.row.get(toRow).selected;\n                fromCol = 0;\n                toCol = Infinity;\n            }\n\n            selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected);\n        } else {\n\n\n            var focusRow = row;\n            if (focusRow < 0) {\n                focusRow = grid.view.row.toData(grid.rowModel.numHeaders());\n            }\n            var focusCol = col;\n            if (focusCol < 0) {\n                focusCol = grid.view.col.toData(grid.colModel.numHeaders());\n            }\n\n            var headerSelectionRange = createHeaderSelectionRange(row, col);\n            if (headerSelectionRange) {\n                var prevSelections = findFullRowOrColSelections(headerSelectionRange);\n                if (prevSelections.length && isCheckboxMode) {\n                    var selectAll = headerSelectionRange.width === Infinity && headerSelectionRange.height === Infinity && !(grid.rowModel.allSelected() || grid.colModel.allSelected());\n                    prevSelections.forEach(function(prevSelection) {\n                        removeFullRowOrColFromSelection(prevSelection, headerSelectionRange);\n                    });\n                    if (selectAll) {\n                        model.setSelection(headerSelectionRange);\n                    }\n                    model.setFocus(focusRow, focusCol, true, true);\n                } else {\n                    if (ctrlOrCmdPressed && !selectionIsFocus(model.selection)) {\n                        addSelection(model.selection);\n                    } else {\n                        clearOtherSelections();\n                    }\n                    model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);\n                    model.setSelection(headerSelectionRange);\n                }\n\n            } else {\n                if (ctrlOrCmdPressed) {\n                    addSelection(model.selection);\n                }\n                model.setFocus(focusRow, focusCol, ctrlOrCmdPressed);\n            }\n        }\n    });\n\n    function selectFromFocusToCell(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed, wasSelected) {\n        var isCheckboxMode = (fromRow === 0 && toRow === Infinity && model.checkboxModeFor.cols) ||\n            (fromCol === 0 && toCol === Infinity && model.checkboxModeFor.rows);\n        if (!wasSelected || !isCheckboxMode) {\n            setSelectionFromPoints(fromRow, fromCol, toRow, toCol, ctrlOrCmdPressed);\n        } else {\n            var range = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);\n            var prevSelections = findFullRowOrColSelections(range);\n            if (prevSelections.length) {\n                prevSelections.forEach(function(prevSelection) {\n                    removeFullRowOrColFromSelection(prevSelection, range);\n                });\n            }\n        }\n    }\n\n    function colSelectable(col) {\n        var colDescriptor = grid.data.col.get(col);\n        return colDescriptor && colDescriptor.selectable !== false;\n    }\n\n    function createHeaderSelectionRange(row, col) {\n        var headerSelectionRange;\n        if (row < 0 && col < 0) {\n            headerSelectionRange = rangeUtil.createFromPoints(0, 0, Infinity, Infinity);\n        } else if (row < 0) {\n            if (colSelectable(col)) {\n                headerSelectionRange = rangeUtil.createFromPoints(0, col, Infinity, col);\n            }\n        } else if (col < 0) {\n            headerSelectionRange = rangeUtil.createFromPoints(row, 0, row, Infinity);\n        }\n        return headerSelectionRange;\n    }\n\n    function findSelectionByRange(range) {\n        return model.getAllSelections().filter(function(selection) {\n            return rangeUtil.equal(selection, range);\n        })[0];\n    }\n\n    function addOrSetSelection(selection) {\n        if (!selectionIsFocus(model.selection)) {\n            addSelection(selection);\n        } else {\n            model.setSelection(selection);\n        }\n    }\n\n\n\n    function removeFullRowOrColFromSelection(selection, rowOrCol) {\n\n        if (rowOrCol.width === Infinity) { // row\n            var newSelections = [];\n            if (selection.top < rowOrCol.top) { // we need a selection for the top portion\n                var newSelection = {\n                    top: selection.top,\n                    height: rowOrCol.top - selection.top,\n                    left: selection.left,\n                    width: selection.width\n                };\n                newSelections.push(newSelection);\n            }\n\n            var bottomRow = selection.top + selection.height - 1;\n            if (bottomRow > rowOrCol.top + rowOrCol.height - 1) { // we need a selection for the bottom portion\n                newSelections.push({\n                    top: rowOrCol.top + rowOrCol.height,\n                    height: bottomRow - (rowOrCol.top + rowOrCol.height - 1),\n                    left: selection.left,\n                    width: selection.width\n                });\n            }\n            removeSelection(selection);\n            newSelections.forEach(addOrSetSelection);\n            syncSelectionToHeaders();\n        }\n\n        if (rowOrCol.height === Infinity) { // col\n        }\n    }\n\n    function findFullRowOrColSelections(range) {\n        return model.getAllSelections().filter(function(selection) {\n            return (selection.height === Infinity && selection.top === 0 && rangeUtil.intersect([selection.left, selection.width], [range.left, range.width])) ||\n                (selection.width === Infinity && selection.left === 0 && rangeUtil.intersect([selection.top, selection.height], [range.top, range.height]));\n        });\n    }\n\n    function addSelection(range) {\n        model.otherSelections.push(createAndAddSelectionDecorator(range.top, range.left, range.height, range.width));\n    }\n\n    model._rowSelectionClasses = [];\n    model._colSelectionClasses = [];\n    // row col selection\n    function handleRowColSelectionChange(rowOrCol) {\n        var decoratorsField = ('_' + rowOrCol + 'SelectionClasses');\n        model[decoratorsField].forEach(function(selectionDecorator) {\n            grid.cellClasses.remove(selectionDecorator);\n        });\n        model[decoratorsField] = [];\n\n        if (grid[rowOrCol + 'Model'].allSelected()) {\n            var top = rowOrCol === 'row' ? Infinity : 0;\n            var left = rowOrCol === 'col' ? Infinity : 0;\n            var decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');\n            grid.cellClasses.add(decorator);\n            model[decoratorsField].push(decorator);\n        } else {\n            grid[rowOrCol + 'Model'].getSelected().forEach(function(index) {\n                var virtualIndex = grid[rowOrCol + 'Model'].toVirtual(index);\n                var top = rowOrCol === 'row' ? virtualIndex : 0;\n                var left = rowOrCol === 'col' ? virtualIndex : 0;\n                var decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');\n                grid.cellClasses.add(decorator);\n                model[decoratorsField].push(decorator);\n            });\n        }\n    }\n\n    grid.eventLoop.bind('grid-row-selection-change', function() {\n        handleRowColSelectionChange('row');\n    });\n\n    grid.eventLoop.bind('grid-col-selection-change', function() {\n        handleRowColSelectionChange('col');\n    });\n\n    function createAndAddSelectionDecorator() {\n        var selection = grid.decorators.create.apply(this, arguments);\n        var defaultRender = selection.render;\n        selection.render = function() {\n            var div = defaultRender();\n            div.setAttribute('class', 'grid-selection');\n            return div;\n        };\n        grid.decorators.add(selection);\n        return selection;\n    }\n\n    var selection = createAndAddSelectionDecorator();\n\n    function syncSelectionToHeaders() {\n        grid.colModel.clearSelected(true);\n        grid.rowModel.clearSelected(true);\n        model.getAllSelections().forEach(function(selection) {\n            if (selection) {\n                maybeSelectHeaderFromSelection(selection);\n            }\n        });\n    }\n\n    model.getAllSelections = function() {\n        var selections = [];\n        if (model.selection) {\n            selections.push(model.selection);\n        }\n        return selections.concat(model.otherSelections);\n    };\n\n    function maybeSelectHeaderFromSelection(range, deselect) {\n        var indexes;\n        if (range.height === Infinity) {\n            indexes = grid.data.col.indexes({\n                from: range.left,\n                length: range.width\n            });\n            if (deselect) {\n                grid.colModel.deselect(indexes);\n            } else {\n                grid.colModel.select(indexes);\n            }\n        }\n        if (range.width === Infinity) {\n            indexes = grid.data.row.indexes({\n                from: range.top,\n                length: range.height\n            });\n            if (deselect) {\n                grid.rowModel.deselect(indexes);\n            } else {\n                grid.rowModel.select(indexes);\n            }\n        }\n    }\n\n    function selectionIsFocus(selection) {\n        return selection.height === 1 && selection.width === 1 && !model.otherSelections.length;\n    }\n\n    model.setSelection = function setSelection(newSelection) {\n        var height = newSelection.height;\n        var width = newSelection.width;\n        if (selectionIsFocus(newSelection)) {\n            height = -1;\n            width = -1;\n        }\n        selection.top = newSelection.top;\n        selection.left = newSelection.left;\n        selection.height = height;\n        selection.width = width;\n        // select the columns to match\n        syncSelectionToHeaders();\n    };\n\n\n    function setSelectionToFocus() {\n        model.setSelection({\n            top: model.focus.row,\n            left: model.focus.col,\n            height: 1,\n            width: 1\n        });\n    }\n\n    function clearOtherSelections() {\n        grid.decorators.remove(model.otherSelections);\n        model.otherSelections = [];\n        syncSelectionToHeaders();\n    }\n\n    function removeSelection(selection) {\n        if (rangeUtil.equal(selection, model.selection)) {\n            if (model.otherSelections.length) {\n                var lastSelection = model.otherSelections.pop();\n                grid.decorators.remove(lastSelection);\n                model.setSelection(lastSelection);\n            } else {\n                setSelectionToFocus();\n            }\n        } else {\n            var index = model.otherSelections.indexOf(selection);\n            if (index !== -1) {\n                model.otherSelections.splice(index, 1);\n                grid.decorators.remove(selection);\n            }\n        }\n        syncSelectionToHeaders();\n    }\n\n    function setSelectionFromPoints(fromRow, fromCol, toRow, toCol, dontClearOthers) {\n        if (!dontClearOthers) {\n            clearOtherSelections();\n        }\n        toRow = util.clamp(toRow, 0, Infinity);\n        toCol = util.clamp(toCol, 0, Infinity);\n        var newSelection = rangeUtil.createFromPoints(fromRow, fromCol, toRow, toCol);\n        model.setSelection(newSelection);\n    }\n\n    selection._onDragStart = function(e) {\n        if (!isNavableMouseEvent(e)) {\n            return;\n        }\n        if (e.enableAutoScroll) {\n            e.enableAutoScroll();\n        }\n        var fromRow = model.focus.row;\n        var fromCol = model.focus.col;\n        var startCol = e.col;\n        var startRow = e.row;\n        var wasSelected;\n        var toRow, toCol;\n        if (startRow < 0) {\n            // these are notted because mousedwon actually inverts the intial selection\n            wasSelected = !grid.data.col.get(startCol).selected;\n            fromRow = 0;\n            toRow = Infinity;\n\n        }\n        if (startCol < 0) {\n            // these are notted because mousedwon actually inverts the intial selection\n            wasSelected = !grid.data.row.get(startRow).selected;\n            fromCol = 0;\n            toCol = Infinity;\n        }\n        var unbindDrag = grid.eventLoop.bind('grid-cell-drag', function(e) {\n            toRow = toRow !== Infinity ? e.row : toRow;\n            toCol = toCol !== Infinity ? e.col : toCol;\n            if (toCol !== Infinity && !colSelectable(toCol)) {\n                return;\n            }\n\n            var fixedRows = grid.rowModel.numFixed(true);\n            if (startRow < fixedRows && toRow > fixedRows && toRow !== Infinity) {\n                startRow = toRow = grid.rowModel.numFixed();\n                grid.cellScrollModel.scrollTo(0, grid.cellScrollModel.col);\n            }\n            var fixedCols = grid.colModel.numFixed(true);\n            if (startCol < fixedCols && toCol > fixedCols && toCol !== Infinity) {\n                startCol = toCol = grid.colModel.numFixed();\n                grid.cellScrollModel.scrollTo(grid.cellScrollModel.row, 0);\n            }\n            if (isNaN(toRow) || isNaN(toCol)) {\n                return; //don't try to select when NaN\n            }\n            selectFromFocusToCell(fromRow, fromCol, toRow, toCol, true, wasSelected); // always pass true because if it was to be cleared mousedown should have handled that\n        });\n        var unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function() {\n            unbindDrag();\n            unbindDragEnd();\n        });\n    };\n\n    grid.eventLoop.bind('grid-drag-start', selection._onDragStart);\n    setSelectionToFocus();\n    model._selectionDecorator = selection;\n\n    Object.defineProperty(model, 'selection', {\n        get: function() {\n            if (selection.height === -1) { // cleared selection default to focus\n                return {\n                    top: model.focus.row,\n                    left: model.focus.col,\n                    height: 1,\n                    width: 1\n                };\n            }\n            return selection;\n        }\n    });\n\n    model.getAllSelectedRanges = function() {\n        var selectionRange = grid.navigationModel.selection;\n        // valid selection range cannot go to -1\n        if (selectionRange.top === -1) {\n            selectionRange = {\n                top: grid.navigationModel.focus.row,\n                left: grid.navigationModel.focus.col,\n                width: 1,\n                height: 1\n            };\n        }\n        return [selectionRange].concat(model.otherSelections);\n    };\n\n    model.clearSelection = function() {\n        clearOtherSelections();\n        setSelectionToFocus();\n    }\n\n    function clearSelectionFromModelChange(e) {\n        if (e.action === 'size') { // don't clear for resize but all other changes for now will clear selection\n            return;\n        }\n        model.clearSelection();\n\n    }\n\n    grid.eventLoop.bind('grid-col-change', clearSelectionFromModelChange);\n    grid.eventLoop.bind('grid-row-change', clearSelectionFromModelChange);\n    return model;\n};",
    "module.exports = function () {\n    //a noop function to use\n};",
    "module.exports = function () {\n    return arguments[0];\n};",
    "var util = require('../util');\nvar debounce = require('../debounce');\nvar capitalize = require('capitalize');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n    var model = {\n        top: 0,\n        left: 0,\n        maxScroll: {},\n        maxIsAllTheWayFor: {\n            height: false,\n            width: false\n        }\n    };\n    var scrollBarWidth = 10;\n\n    grid.eventLoop.bind('grid-virtual-pixel-cell-change', function() {\n        var scrollHeight = grid.virtualPixelCellModel.totalHeight() - grid.virtualPixelCellModel.fixedHeight();\n        var scrollWidth = grid.virtualPixelCellModel.totalWidth() - grid.virtualPixelCellModel.fixedWidth();\n        model.setScrollSize(scrollHeight, scrollWidth);\n        cacheMaxScroll();\n        sizeScrollBars();\n    });\n\n\n    grid.eventLoop.bind('grid-viewport-change', function() {\n        cacheMaxScroll();\n        sizeScrollBars();\n    });\n\n    function cacheMaxScroll() {\n        model.maxScroll.height = getMaxScroll('height');\n        model.maxScroll.width = getMaxScroll('width');\n    }\n\n    //assumes a standardized wheel event that we create through the mousewheel package\n    grid.eventLoop.bind('mousewheel', function handleMouseWheel(e) {\n        if (getScrollParent(e.target, grid.container) !== grid.container) {\n            return;\n        }\n        var deltaY = e.deltaY;\n        var deltaX = e.deltaX;\n        model.scrollTo(model.top - deltaY, model.left - deltaX, true);\n        e.preventDefault();\n        debouncedNotify();\n    });\n\n    model.setScrollSize = function(h, w) {\n        model.height = h;\n        model.width = w;\n    };\n\n    function notifyListeners() {\n        //TODO: possibly keep track of delta since last update and send it along. for now, no\n        grid.eventLoop.fire('grid-pixel-scroll');\n\n        //update the cell scroll\n        var scrollTop = model.top;\n        var row = grid.virtualPixelCellModel.getRow(scrollTop + grid.virtualPixelCellModel.fixedHeight()) - grid.rowModel.numFixed();\n\n        var scrollLeft = model.left;\n        var col = grid.virtualPixelCellModel.getCol(scrollLeft + grid.virtualPixelCellModel.fixedWidth()) - grid.colModel.numFixed();\n\n        grid.cellScrollModel.scrollTo(row, col, undefined, true);\n    }\n\n    var debouncedNotify = debounce(notifyListeners, 1);\n\n    model.scrollTo = function(top, left, dontNotify) {\n        model.top = util.clamp(top, 0, model.maxScroll.height);\n        model.left = util.clamp(left, 0, model.maxScroll.width);\n        positionScrollBars();\n\n        if (!dontNotify) {\n            notifyListeners();\n        }\n\n\n    };\n\n\n    /* SCROLL BAR LOGIC */\n    function getScrollPositionFromReal(scrollBarRealClickCoord, heightWidth, vertHorz) {\n        var scrollBarTopClick = scrollBarRealClickCoord - grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();\n        var scrollRatio = scrollBarTopClick / getMaxScrollBarCoord(heightWidth, vertHorz);\n        var scrollCoord = scrollRatio * model.maxScroll[heightWidth];\n        return scrollCoord;\n    }\n\n    function makeScrollBarDecorator(isHorz) {\n        var decorator = grid.decorators.create();\n        var xOrY = isHorz ? 'X' : 'Y';\n        var heightWidth = isHorz ? 'width' : 'height';\n        var vertHorz = isHorz ? 'horz' : 'vert';\n        var gridCoordField = 'grid' + xOrY;\n        var layerCoordField = 'layer' + xOrY;\n        var viewPortClampFn = grid.viewPort['clamp' + xOrY];\n\n        decorator.postRender = function(scrollBarElem) {\n            scrollBarElem.setAttribute('class', 'grid-scroll-bar');\n            decorator._onDragStart = function(e) {\n                if (e.target !== scrollBarElem) {\n                    return;\n                }\n                var scrollBarOffset = e[layerCoordField];\n\n                decorator._unbindDrag = grid.eventLoop.bind('grid-drag', function(e) {\n                    grid.eventLoop.stopBubbling(e);\n                    var gridCoord = viewPortClampFn(e[gridCoordField]);\n                    var scrollBarRealClickCoord = gridCoord - scrollBarOffset;\n                    var scrollCoord = getScrollPositionFromReal(scrollBarRealClickCoord, heightWidth, vertHorz);\n                    if (isHorz) {\n                        model.scrollTo(model.top, scrollCoord);\n                    } else {\n                        model.scrollTo(scrollCoord, model.left);\n                    }\n                });\n\n                decorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function() {\n                    decorator._unbindDrag();\n                    decorator._unbindDragEnd();\n                });\n\n                e.stopPropagation();\n            };\n\n            grid.eventLoop.bind('grid-drag-start', scrollBarElem, decorator._onDragStart);\n            grid.eventLoop.bind('mousedown', scrollBarElem, function(e) {\n                grid.eventLoop.stopBubbling(e);\n            });\n\n            return scrollBarElem;\n        };\n\n        decorator.units = 'px';\n        decorator.space = 'real';\n\n        return decorator;\n    }\n\n    model.vertScrollBar = makeScrollBarDecorator();\n    model.horzScrollBar = makeScrollBarDecorator(true);\n    model.vertScrollBar.width = scrollBarWidth;\n    model.horzScrollBar.height = scrollBarWidth;\n\n    function getMaxScroll(heightWidth) {\n        if (model.maxIsAllTheWayFor[heightWidth]) {\n            return model[heightWidth] - 1;\n        }\n        var rowOrCol = heightWidth === 'height' ? 'row' : 'col';\n        var scrollLength = model[heightWidth];\n        var viewScrollHeightOrWidth = getViewScrollHeightOrWidth(heightWidth);\n        var firstScrollableCell = grid[rowOrCol + 'Model'].numFixed();\n        while (scrollLength > viewScrollHeightOrWidth - 10) {\n            scrollLength -= grid.virtualPixelCellModel[heightWidth](firstScrollableCell); - firstScrollableCell++;\n        }\n        return model[heightWidth] - scrollLength;\n\n    }\n\n    model._getMaxScroll = getMaxScroll;\n\n    function getScrollRatioFromVirtualScrollCoords(scroll, heightWidth) {\n        var maxScroll = model.maxScroll[heightWidth];\n        var scrollRatio = scroll / maxScroll;\n        return scrollRatio;\n    }\n\n    function getMaxScrollBarCoord(heightWidth, vertHorz) {\n        return getViewScrollHeightOrWidth(heightWidth) - model[vertHorz + 'ScrollBar'][heightWidth];\n    }\n\n    function getRealScrollBarPosition(scroll, heightWidth, vertHorz) {\n        var scrollRatio = getScrollRatioFromVirtualScrollCoords(scroll, heightWidth);\n        var maxScrollBarScroll = getMaxScrollBarCoord(heightWidth, vertHorz);\n        //in scroll bar coords\n        var scrollBarCoord = scrollRatio * maxScrollBarScroll;\n        //add the fixed height to translate back into real coords\n        return scrollBarCoord + grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();\n    }\n\n    model._getRealScrollBarPosition = getRealScrollBarPosition;\n    model._getScrollPositionFromReal = getScrollPositionFromReal;\n\n    function calcScrollBarRealTop() {\n        return getRealScrollBarPosition(model.top, 'height', 'vert');\n    }\n\n    function calcScrollBarRealLeft() {\n        return getRealScrollBarPosition(model.left, 'width', 'horz');\n    }\n\n    function positionScrollBars() {\n        model.vertScrollBar.top = calcScrollBarRealTop();\n        model.horzScrollBar.left = calcScrollBarRealLeft();\n    }\n\n    function getViewScrollHeightOrWidth(heightWidth) {\n        return grid.viewPort[heightWidth] - grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();\n    }\n\n    function getScrollableViewWidth() {\n        return getViewScrollHeightOrWidth('width');\n    }\n\n    function getScrollableViewHeight() {\n        return getViewScrollHeightOrWidth('height');\n    }\n\n    function sizeScrollBars() {\n        model.vertScrollBar.left = grid.viewPort.width - scrollBarWidth;\n        model.horzScrollBar.top = grid.viewPort.height - scrollBarWidth;\n        var scrollableViewHeight = getScrollableViewHeight();\n        var scrollableViewWidth = getScrollableViewWidth();\n        model.vertScrollBar.height = Math.max(scrollableViewHeight / grid.virtualPixelCellModel.totalHeight() * scrollableViewHeight, 20);\n        model.horzScrollBar.width = Math.max(scrollableViewWidth / grid.virtualPixelCellModel.totalWidth() * scrollableViewWidth, 20);\n        if (model.vertScrollBar.height >= scrollableViewHeight) {\n            model.vertScrollBar.height = -1;\n        }\n\n        if (model.horzScrollBar.width >= scrollableViewWidth) {\n            model.horzScrollBar.width = -1;\n        }\n        positionScrollBars();\n    }\n\n    grid.decorators.add(model.vertScrollBar);\n    grid.decorators.add(model.horzScrollBar);\n    /* END SCROLL BAR LOGIC */\n\n    function getScrollParent(elem, stopParent) {\n        stopParent = stopParent || document;\n        if (!elem) {\n            return stopParent;\n        }\n\n        var position = elem.style.position,\n            excludeStaticParent = position === 'absolute',\n            overflowRegex = /(auto|scroll)/,\n            scrollParent = elem;\n\n        while (!!(scrollParent = scrollParent.parentElement) && scrollParent !== stopParent) {\n            if (excludeStaticParent && scrollParent.style.position === 'static') {\n                continue;\n            }\n\n            var computedStyle = getComputedStyle(scrollParent);\n\n            if (overflowRegex.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n                break;\n            }\n        }\n\n        return position === 'fixed' || !scrollParent || scrollParent === elem ? elem.ownerDocument || stopParent : scrollParent;\n    }\n\n    return model;\n};",
    "var addDirtyProps = require('../add-dirty-props');\nmodule.exports = function(range, dirtyClean, parentDirtyClean, propOpts) {\n    range = range || {}; //allow mixin functionality\n    range.isDirty = dirtyClean.isDirty;\n\n    var watchedProperties = ['top', 'left', 'height', 'width', 'units', 'space'];\n    if (propOpts) {\n        watchedProperties = watchedProperties.map(function(propName) {\n            return {\n                name: propName,\n                onDirty: propOpts.onDirty,\n                preDirty: propOpts.preDirty\n            }\n        });\n    }\n    var dirtyCleans = [dirtyClean];\n    if (parentDirtyClean) {\n        dirtyCleans.push(parentDirtyClean);\n    }\n\n    addDirtyProps(range, watchedProperties, dirtyCleans);\n    // defaults\n    range.units = 'cell';\n    range.space = 'data';\n\n    return range;\n};",
    "module.exports = {\n    //takes a point and a length as the ranges in array form\n    intersect: function(range1, range2) {\n        var range2Start = range2[0];\n        var range1Start = range1[0];\n        var range1End = range1Start + range1[1] - 1;\n        var range2End = range2Start + range2[1] - 1;\n        if (range2Start > range1End || range2End < range1Start) {\n            return null;\n        }\n        var resultStart = (range1Start > range2Start ? range1Start : range2Start);\n        var resultEnd = (range1End < range2End ? range1End : range2End);\n        return [\n            resultStart,\n            resultEnd - resultStart + 1\n        ];\n    },\n    //takes a point and a length as the ranges in array form\n    union: function(range1, range2) {\n        if (!range1) {\n            return range2;\n        }\n        if (!range2) {\n            return range1;\n        }\n        var range2Start = range2[0];\n        var range2End = range2Start + range2[1] - 1;\n        var range1Start = range1[0];\n        var range1End = range1Start + range1[1] - 1;\n        var resultStart = (range1Start < range2Start ? range1Start : range2Start);\n        return [\n            resultStart, (range1End > range2End ? range1End : range2End) - resultStart + 1\n        ];\n    },\n\n    //takes two row, col points and creates a normal position range\n    createFromPoints: function(r1, c1, r2, c2) {\n        var range = {};\n        if (r1 < r2) {\n            range.top = r1;\n            range.height = r2 - r1 + 1;\n        } else {\n            range.top = r2;\n            range.height = r1 - r2 + 1;\n        }\n\n        if (c1 < c2) {\n            range.left = c1;\n            range.width = c2 - c1 + 1;\n        } else {\n            range.left = c2;\n            range.width = c1 - c2 + 1;\n        }\n        return range;\n    },\n    iterate: function() {\n        var args = this.getArgs(arguments);\n        var range = args.range;\n        var cellFn = args.cellFn;\n        var rowFn = args.rowFn;\n        for (var r = range.top; r < range.top + range.height; r++) {\n            var rowResult;\n            if (rowFn) {\n                rowResult = rowFn(r);\n            }\n            for (var c = range.left; c < range.left + range.width; c++) {\n                if (cellFn) {\n                    cellFn(r, c, rowResult);\n                }\n            }\n        }\n    },\n    getArgs: function(args) {\n        var range = args[0];\n        var cellFn;\n        var rowFn;\n        if (args.length === 2) {\n            cellFn = args[1];\n        } else if (args.length === 3) {\n            cellFn = args[2];\n            rowFn = args[1];\n        }\n        return {\n            range: range,\n            cellFn: cellFn,\n            rowFn: rowFn\n        };\n    },\n    equal: function(r1, r2) {\n        return r1.top === r2.top && r1.left === r2.left && r1.width === r2.width && r1.height === r2.height;\n    }\n};",
    "module.exports = function (_grid) {\n    var grid = _grid;\n\n    var api = require('../abstract-row-col-model')(grid, 'row', 'height', 30);\n\n    return api;\n};",
    "module.exports = function(_grid) {\n    var grid = _grid;\n\n    var api = {\n        _decorators: {}\n    };\n\n    function setColShowing(col) {\n        grid.colModel.get(col).hidden = false;\n    }\n\n    function doWhileHidden(col, fn) {\n        while (grid.colModel.get(col - 1).hidden) {\n            col--;\n            fn && fn(col);\n        }\n        return col;\n    }\n\n    function createDecorator(col, right) {\n        var headerDecorator = grid.decorators.create(0, col, 1, 1, 'cell', 'virtual');\n\n        headerDecorator.postRender = function(div) {\n\n            if (right) {\n                div.style.transform = 'translate(50%, -50%)';\n                div.style.webkitTransform = 'translate(50%, -50%)';\n                div.style.removeProperty('left');\n            } else {\n                div.style.transform = 'translate(-50%, -50%)';\n                div.style.webkitTransform = 'translate(-50%, -50%)';\n                div.style.removeProperty('right');\n            }\n            div.style.removeProperty('bottom');\n            div.style.top = '50%';\n            div.setAttribute('class', 'show-hidden-cols');\n            div.setAttribute('dts', 'grid_column_unhide_btn');\n\n            grid.eventLoop.bind('click', div, function() {\n                doWhileHidden(col, setColShowing);\n            });\n        };\n        return headerDecorator;\n    }\n\n    function maybeRemoveDecorator(col) {\n        if (api._decorators[col]) {\n            var decorator = api._decorators[col];\n            grid.decorators.remove(decorator);\n            api._decorators[col] = undefined;\n        }\n    }\n\n    grid.eventLoop.bind('grid-col-change', function(e) {\n        if (e.action === 'hide' || e.action === 'add') {\n            e.descriptors.forEach(function(descriptor) {\n                var col = descriptor.index;\n                if (!col && col !== 0) {\n                    return;\n                }\n                if (descriptor.hidden) {\n                    var decCol = col + 1;\n                    var rightSide = col === grid.colModel.length(true) - 1;\n                    if (rightSide) {\n                        //if we're last we actually have to backtrack to the last showing column\n                        var lastHiddenCol = doWhileHidden(col);\n                        decCol = lastHiddenCol - 1;\n\n                    }\n                    maybeRemoveDecorator(col);\n                    var decorator = createDecorator(decCol, rightSide);\n                    grid.decorators.add(decorator);\n                    api._decorators[col] = decorator;\n                } else {\n                    maybeRemoveDecorator(col);\n                }\n            });\n        }\n    });\n\n    return api;\n};",
    "var util = require('../util');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n\n    var cellData = [];\n    var headerData = [];\n    var sortedCol;\n    var ascending;\n    var dirtyClean = require('../dirty-clean')(grid);\n    var internalSet = function(data, r, c, datum) {\n        if (!data[r]) {\n            data[r] = [];\n        }\n        data[r][c] = datum;\n        dirtyClean.setDirty();\n    };\n\n    var api = {\n        isDirty: dirtyClean.isDirty,\n        set: function(r, c, datum) {\n            var data = arguments[0];\n            if (!util.isArray(data)) {\n                if (typeof datum === 'string') {\n                    datum = {\n                        value: datum.replace('[rR]', '').replace('[cC]', '').split(' ')\n                    };\n                }\n                data = [{\n                    row: r,\n                    col: c,\n                    data: datum\n                }];\n            }\n            data.forEach(function(change) {\n                internalSet(cellData, change.row, change.col, change.data);\n            });\n        },\n        setHeader: function(r, c, datum) {\n            internalSet(headerData, r, c, datum);\n        },\n        get: function(r, c) {\n            var rowDescriptor = grid.rowModel.row(r);\n            if (!rowDescriptor) {\n                return {\n                    formatted: ''\n                };\n            }\n            var dataRow = cellData[rowDescriptor.dataRow];\n            var datum = dataRow && dataRow[grid.colModel.col(c).dataCol];\n            var value = datum && datum.value;\n            if (value === undefined) {\n                console.log((value && 'r' + value[0] + ' c' + value[1]) || '');\n            }\n            return {\n                value: value,\n                formatted: (value && (rowDescriptor.dataLayer ? ' s' + rowDescriptor.dataLayer + ' ' : '') + 'r' + value[0] + ' c' + value[1]) || ''\n            };\n        },\n        getCopyData: function(r, c) {\n            return api.get(r, c).formatted;\n        },\n        getHeader: function(r, c) {\n            var dataRow = headerData[grid.rowModel.get(r).dataRow];\n\n            var datum = dataRow && dataRow[grid.colModel.get(c).dataCol];\n            var value = datum && datum.value;\n            return {\n                value: value,\n                formatted: value && 'hr' + value[0] + ' hc' + value[1] || ''\n            };\n        },\n\n        toggleSort: function(c) {\n            var retVal = -1;\n            var compareMethod = function(val1, val2) {\n                return val1 < (val2) ? retVal : -1 * retVal;\n            };\n            if (c === sortedCol) {\n                if (ascending) {\n                    retVal = 1;\n                }\n                ascending = !ascending;\n            } else {\n                sortedCol = c;\n                ascending = true;\n            }\n            cellData.sort(function(dataRow1, dataRow2) {\n                if (!dataRow1 || !dataRow1[c]) {\n                    return retVal;\n                }\n                if (!dataRow2 || !dataRow2[c]) {\n                    return retVal * -1;\n                }\n                return compareMethod(dataRow1[c].value, dataRow2[c].value);\n            });\n            dirtyClean.setDirty();\n        }\n    };\n\n    return api;\n};",
    "module.exports.stringify = function (data) {\n    var string = '';\n    data.forEach(function (row, r) {\n        row.forEach(function (value, c) {\n            if (value.indexOf('\\n') !== -1 || value.indexOf('\\t') !== -1 || value.indexOf('\"') !== -1) {\n                //replace \" with \"\" to escape and wrap the whole value in quotes \n                value = '\"' + value.replace(/\"/g, '\"\"') + '\"';\n            }\n            string += value;\n            if (c !== row.length - 1) {\n                string += '\\t'\n            }\n        });\n        if (r !== data.length - 1) {\n            string += '\\n';\n        }\n\n    });\n    return string;\n};\n\n// ref: http://stackoverflow.com/a/1293163/2343\n// This will parse a delimited string into an array of\n// arrays. The default delimiter is the comma, but this\n// can be overriden in the second argument.\nfunction DSVToArray(strData, strDelimiter) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    strDelimiter = (strDelimiter || \",\");\n\n    // Create a regular expression to parse the CSV values.\n    var objPattern = new RegExp(\n        (\n            // Delimiters.\n        \"(\\\\\" + strDelimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n            // Quoted fields.\n        \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n            // Standard fields.\n        \"([^\\\"\\\\\" + strDelimiter + \"\\\\r\\\\n]+))\"\n        ),\n        \"gi\"\n    );\n\n\n    // Create an array to hold our data. Give the array\n    // a default empty first row.\n    var arrData = [[]];\n\n    // Create an array to hold our individual pattern\n    // matching groups.\n    var arrMatches = null;\n\n\n    // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n    while (arrMatches = objPattern.exec(strData)) {\n\n        // Get the delimiter that was found.\n        var strMatchedDelimiter = arrMatches[1];\n\n        // Check to see if the given delimiter has a length\n        // (is not the start of string) and if it matches\n        // field delimiter. If id does not, then we know\n        // that this delimiter is a row delimiter.\n        if (\n            strMatchedDelimiter.length &&\n            strMatchedDelimiter !== strDelimiter\n        ) {\n\n            // Since we have reached a new row of data,\n            // add an empty row to our data array.\n            arrData.push([]);\n\n        }\n\n        var strMatchedValue;\n\n        // Now that we have our delimiter out of the way,\n        // let's check to see which kind of value we\n        // captured (quoted or unquoted).\n        if (arrMatches[2]) {\n\n            // We found a quoted value. When we capture\n            // this value, unescape any double quotes.\n            strMatchedValue = arrMatches[2].replace(\n                new RegExp(\"\\\"\\\"\", \"g\"),\n                \"\\\"\"\n            );\n\n        } else {\n\n            // We found a non-quoted value.\n            strMatchedValue = arrMatches[3];\n\n        }\n\n\n        // Now that we have our value string, let's add\n        // it to the data array.\n        arrData[arrData.length - 1].push(strMatchedValue);\n    }\n\n    // Return the parsed data.\n    return (arrData[0].length || !strData) && ( arrData ) || [[strData]];\n}\n\n\nmodule.exports.parse = function (string) {\n    return DSVToArray(string, '\\t');\n};",
    "module.exports = {\n    clamp: function(num, min, max, returnNaN) {\n        if (num > max) {\n            return returnNaN ? NaN : max;\n        }\n        if (num < min) {\n            return returnNaN ? NaN : min;\n        }\n        return num;\n    },\n    isNumber: function(number) {\n        return typeof number === 'number' && !isNaN(number);\n    },\n    isElement: function(node) {\n        return !!(node &&\n            (node.nodeName || // we are a direct element\n                (node.prop && node.attr && node.find))); // we have an on and find method part of jquery API\n    },\n    isArray: function(value) {\n        return Object.prototype.toString.call(value) === '[object Array]';\n    },\n    position: function(elem, t, l, b, r) {\n        if (t != null) {\n            elem.style.top = t + 'px';\n        }\n        if (t != null) {\n            elem.style.left = l + 'px';\n        }\n        if (t != null) {\n            elem.style.bottom = b + 'px';\n        }\n        if (t != null) {\n            elem.style.right = r + 'px';\n        }\n        elem.style.position = 'absolute';\n\n    }\n};",
    "var customEvent = require('../custom-event');\nvar debounce = require('../debounce');\nvar util = require('../util');\n\n\nmodule.exports = function(_grid) {\n    var viewLayer = {};\n\n    var grid = _grid;\n    var container;\n    var root;\n    var cellContainer;\n    var decoratorContainer;\n    var borderWidth;\n\n    var GRID_CELL_CONTAINER_BASE_CLASS = 'grid-cells';\n    var GRID_VIEW_ROOT_CLASS = 'js-grid-view-root';\n    var CELL_CLASS = 'grid-cell';\n\n    var cells; // matrix of rendered cell elements;\n    var rows; // array of all rendered rows\n    var builtCols; // map from col index to an array of built elements for the column to update on scroll\n    var builtRows; // map from row index to an array of built elements for the row to update on scroll\n\n    // add the cell classes through the standard method\n    grid.cellClasses.add(grid.cellClasses.create(0, 0, CELL_CLASS, Infinity, Infinity, 'virtual'));\n\n    var rowHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-row-header', Infinity, 0, 'virtual');\n    var colHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-col-header', 0, Infinity, 'virtual');\n    var fixedColClasses = grid.cellClasses.create(0, -1, 'grid-last-fixed-col', Infinity, 1, 'virtual');\n    var fixedRowClasses = grid.cellClasses.create(-1, 0, 'grid-last-fixed-row', 1, Infinity, 'virtual');\n\n    grid.cellClasses.add(rowHeaderClasses);\n    grid.cellClasses.add(colHeaderClasses);\n    grid.cellClasses.add(fixedRowClasses);\n    grid.cellClasses.add(fixedColClasses);\n\n\n    grid.eventLoop.bind('grid-col-change', function() {\n        fixedColClasses.left = grid.colModel.numFixed() - 1;\n        rowHeaderClasses.width = grid.colModel.numHeaders();\n    });\n\n    grid.eventLoop.bind('grid-row-change', function() {\n        fixedRowClasses.top = grid.rowModel.numFixed() - 1;\n        colHeaderClasses.height = grid.rowModel.numHeaders();\n    });\n\n\n    viewLayer.build = function(elem) {\n        cleanup();\n\n        container = elem;\n\n        cellContainer = document.createElement('div');\n        cellContainer.setAttribute('dts', 'grid-cells');\n        cellContainer.setAttribute('class', GRID_CELL_CONTAINER_BASE_CLASS);\n        util.position(cellContainer, 0, 0, 0, 0);\n        cellContainer.style.zIndex = 0;\n\n        decoratorContainer = document.createElement('div');\n        decoratorContainer.setAttribute('dts', 'grid-decorators');\n        util.position(decoratorContainer, 0, 0, 0, 0);\n        decoratorContainer.style.zIndex = 0;\n        decoratorContainer.style.pointerEvents = 'none';\n\n        root = document.createElement('div');\n        root.setAttribute('class', GRID_VIEW_ROOT_CLASS);\n\n        root.appendChild(cellContainer);\n        root.appendChild(decoratorContainer);\n\n        container.appendChild(root);\n\n    };\n\n\n    function measureBorderWidth() {\n        // read the border width, for the rare case of larger than 1px borders, otherwise the draw will default to 1\n        if (borderWidth) {\n            return;\n        }\n        var jsGridCell = cells[0] && cells[0][0];\n        if (jsGridCell) {\n            var oldClass = jsGridCell.className;\n            jsGridCell.className = CELL_CLASS;\n            var computedStyle = getComputedStyle(jsGridCell);\n            var borderWidthProp = computedStyle.getPropertyValue('border-left-width');\n            borderWidth = parseInt(borderWidthProp);\n            jsGridCell.className = oldClass;\n        }\n        borderWidth = isNaN(borderWidth) || !borderWidth ? undefined : borderWidth;\n        return borderWidth;\n    }\n\n    // only draw once per js turn, may need to create a synchronous version\n    viewLayer.draw = debounce(function() {\n        viewLayer._draw();\n    }, 1);\n\n    viewLayer._draw = function() {\n        // return if we haven't built yet\n        if (!container) {\n            return;\n        }\n\n        var rebuilt = grid.viewPort.isDirty();\n        if (rebuilt) {\n            viewLayer._buildCells(cellContainer);\n        }\n\n        var builtColsDirty = grid.colModel.areBuildersDirty();\n        if (rebuilt || builtColsDirty) {\n            viewLayer._buildCols();\n        }\n\n        var builtRowsDirty = grid.rowModel.areBuildersDirty();\n        if (rebuilt || builtRowsDirty) {\n            viewLayer._buildRows();\n        }\n\n        var cellsPositionOrSizeChanged = grid.colModel.isDirty() || grid.rowModel.isDirty() || grid.cellScrollModel.isDirty();\n\n        if (grid.cellClasses.isDirty() || rebuilt || cellsPositionOrSizeChanged) {\n            viewLayer._drawCellClasses();\n        }\n\n        if (rebuilt || cellsPositionOrSizeChanged || builtColsDirty || builtRowsDirty || grid.dataModel.isDirty()) {\n            viewLayer._drawCells();\n        }\n\n        if (grid.decorators.isDirty() || rebuilt || cellsPositionOrSizeChanged) {\n            viewLayer._drawDecorators(cellsPositionOrSizeChanged);\n        }\n\n        grid.eventLoop.fire('grid-draw');\n    };\n\n    /* CELL LOGIC */\n    function getBorderWidth() {\n        return borderWidth || 1;\n    }\n\n    viewLayer._drawCells = function() {\n        measureBorderWidth();\n        var bWidth = getBorderWidth();\n        var headerRows = grid.rowModel.numHeaders();\n        var headerCols = grid.colModel.numHeaders();\n        var totalVisibleCellWidth = 0;\n        var lastVirtualCol;\n        var lastVirtualRow;\n        // these get calculated once per col and are then cached to save a factor of numRows calls per column\n        var widths = [];\n        var lefts = [];\n        var virtualCols = [];\n\n        grid.viewPort.iterateCells(function drawCell(r, c) {\n            var cell = cells[r][c];\n            // only calculate these once per column since they can't change during draw\n            var width = widths[c] || (widths[c] = grid.viewPort.getColWidth(c));\n            var virtualCol = virtualCols[c] || (virtualCols[c] = grid.viewPort.toVirtualCol(c));\n            // if we got the same vCol we've been clamped and its time to hide this cell\n            // also hide the cell if its width is zero cause ya...\n            if (width === 0 || virtualCol === lastVirtualCol) {\n                cell.style.display = 'none';\n                return;\n            }\n            if (r === 0) {\n                // calculate width for rows later but only do it one time (so on the first row)\n                totalVisibleCellWidth += width;\n            }\n\n            lastVirtualCol = virtualCol;\n            cell.style.display = '';\n            cell.style.width = width + bWidth + 'px';\n            // only calculate these once per column since they can't change during draw\n            var left = lefts[c] || (lefts[c] = grid.viewPort.getColLeft(c));\n\n            cell.style.left = left + 'px';\n\n\n            var virtualRow = grid.viewPort.toVirtualRow(r);\n\n            var data;\n            if (r < headerRows || c < headerCols) {\n                data = grid.dataModel.getHeader(virtualRow, virtualCol);\n            } else {\n                data = grid.dataModel.get(grid.rowModel.toData(virtualRow), grid.colModel.toData(virtualCol));\n            }\n            // artificially only get builders for row headers for now\n            var builder = virtualRow < headerRows && grid.rowModel.get(virtualRow).builder || undefined;\n            var hasRowBuilder = true;\n            if (!builder) {\n                hasRowBuilder = false;\n                builder = grid.colModel.get(virtualCol).builder;\n            }\n\n            var cellChild;\n            if (builder) {\n                var builtElem;\n                if (hasRowBuilder) {\n                    builtElem = builtRows[virtualRow][c];\n                } else {\n                    builtElem = builtCols[virtualCol][r];\n                }\n                cellChild = builder.update(builtElem, {\n                    virtualCol: virtualCol,\n                    virtualRow: virtualRow,\n                    data: data\n                });\n            }\n            // if we didn't get a child from the builder use a regular text node\n            if (!cellChild) {\n                viewLayer.setTextContent(cell, data.formatted);\n            } else {\n                var notSameElem = cell.firstChild !== cellChild;\n                if (cell.firstChild && notSameElem) {\n                    cell.removeChild(cell.firstChild);\n                }\n                if (notSameElem) {\n                    cell.appendChild(cellChild);\n                }\n\n            }\n        }, function drawRow(r) {\n            var height = grid.viewPort.getRowHeight(r);\n            var row = rows[r];\n            var virtualRow = grid.view.row.toVirtual(r);\n            // seeing the same virtual row twice means we've been clamped and it's time to hide the row\n            if (height === 0 || lastVirtualRow === virtualRow) {\n                row.style.display = 'none';\n                return;\n            }\n            lastVirtualRow = virtualRow;\n            row.style.display = '';\n            row.style.height = height + bWidth + 'px';\n            var top = grid.viewPort.getRowTop(r);\n            row.style.top = top + 'px';\n        });\n\n        rows.forEach(function(row) {\n            row.style.width = totalVisibleCellWidth + 'px';\n        });\n\n        if (grid.cellScrollModel.row % 2) {\n            cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS + ' odds';\n        } else {\n            cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS;\n        }\n    };\n\n\n    viewLayer._buildCells = function buildCells(cellContainer) {\n        while (cellContainer.firstChild) {\n            cellContainer.removeChild(cellContainer.firstChild);\n        }\n\n\n        cells = [];\n        rows = [];\n        var row;\n        grid.viewPort.iterateCells(function(r, c) {\n            var cell = buildDivCell();\n            cells[r][c] = cell;\n            row.appendChild(cell);\n        }, function(r) {\n            cells[r] = [];\n            row = document.createElement('div');\n            row.setAttribute('class', 'grid-row');\n            row.setAttribute('dts', 'grid-row');\n            row.style.position = 'absolute';\n            row.style.left = 0;\n            rows[r] = row;\n            cellContainer.appendChild(row);\n        });\n    };\n\n    function buildDivCell() {\n        var cell = document.createElement('div');\n        cell.setAttribute('dts', 'grid-cell');\n        var style = cell.style;\n        style.position = 'absolute';\n        style.boxSizing = 'border-box';\n        style.top = '0px';\n        style.bottom = '0px';\n        return cell;\n    }\n\n    /* END CELL LOGIC */\n\n    /* COL BUILDER LOGIC */\n\n    function destroyRenderedElems(oldElems) {\n        if (!oldElems) {\n            return;\n        }\n        oldElems.forEach(function(oldElem) {\n            if (!oldElem) {\n                return;\n            }\n            var destroyEvent = customEvent('grid-rendered-elem-destroy', true);\n            oldElem.dispatchEvent(destroyEvent);\n        });\n    }\n\n    viewLayer._buildCols = function() {\n        var previouslyBuiltCols = builtCols;\n        builtCols = {};\n        for (var c = 0; c < grid.colModel.length(true); c++) {\n            var builder = grid.colModel.get(c).builder;\n            var oldElems = previouslyBuiltCols && previouslyBuiltCols[c];\n\n            if (builder) {\n                builtCols[c] = [];\n                destroyRenderedElems(oldElems);\n                for (var realRow = 0; realRow < grid.viewPort.rows; realRow++) {\n                    builtCols[c][realRow] = builder.render({\n                        viewRow: realRow,\n                        previousElement: oldElems && oldElems[realRow]\n                    });\n                }\n            }\n        }\n    };\n    /* END COL BUILDER LOGIC */\n\n    /* ROW BUILDER LOGIC\n     *  for now we only build headers\n     * */\n\n    viewLayer._buildRows = function() {\n        var previouslyBuiltRows = builtRows;\n        builtRows = {};\n        for (var r = 0; r < grid.rowModel.numHeaders(); r++) {\n            var builder = grid.rowModel.get(r).builder;\n            var oldElems = previouslyBuiltRows && previouslyBuiltRows[r];\n\n            if (builder) {\n                builtRows[r] = [];\n                destroyRenderedElems(oldElems);\n                for (var realCol = 0; realCol < grid.viewPort.cols; realCol++) {\n                    builtRows[r][realCol] = builder.render({\n                        viewCol: realCol,\n                        previousElement: oldElems && oldElems[realCol]\n                    });\n                }\n            }\n        }\n    };\n    /* END ROW BUILDER LOGIC*/\n\n    /* DECORATOR LOGIC */\n    function setPosition(boundingBox, top, left, height, width) {\n        var style = boundingBox.style;\n        if (height <= 0 || width <= 0) {\n            style.display = 'none';\n            return;\n        }\n        style.display = ''\n        style.top = top + 'px';\n        style.left = left + 'px';\n        style.height = height + 'px';\n        style.width = width + 'px';\n        style.position = 'absolute';\n    }\n\n    function positionDecorator(bounding, t, l, h, w) {\n        setPosition(bounding, t, l, util.clamp(h, 0, grid.viewPort.height), util.clamp(w, 0, grid.viewPort.width));\n    }\n\n    function positionCellDecoratorFromViewCellRange(realCellRange, boundingBox) {\n        var realPxRange = grid.viewPort.toPx(realCellRange);\n        positionDecorator(boundingBox, realPxRange.top, realPxRange.left, realPxRange.height && realPxRange.height + getBorderWidth(), realPxRange.width && realPxRange.width + getBorderWidth());\n    }\n\n    function createRangeForDescriptor(descriptor) {\n        var range = {\n            top: descriptor.top,\n            left: descriptor.left,\n            height: descriptor.height,\n            width: descriptor.width\n        };\n        if (descriptor.space === 'data' && descriptor.units === 'cell') {\n            range.top += grid.rowModel.numHeaders();\n            range.left += grid.colModel.numHeaders();\n        }\n        return range;\n    }\n\n    viewLayer._drawDecorators = function(cellsPositionOrSizeChanged) {\n        var aliveDecorators = grid.decorators.getAlive();\n        aliveDecorators.forEach(function(decorator) {\n\n            var boundingBox = decorator.boundingBox;\n            var hasBeenRendered = !!boundingBox;\n            if (!hasBeenRendered) {\n                boundingBox = document.createElement('div');\n                boundingBox.style.pointerEvents = 'none';\n                decorator.boundingBox = boundingBox;\n                var decElement = decorator.render();\n                if (decElement) {\n                    boundingBox.appendChild(decElement);\n                    decoratorContainer.appendChild(boundingBox);\n                }\n            }\n\n            if (decorator.isDirty() || cellsPositionOrSizeChanged || !hasBeenRendered) {\n                if (decorator.space === 'real') {\n                    switch (decorator.units) {\n                        case 'px':\n                            positionDecorator(boundingBox, decorator.top, decorator.left, decorator.height, decorator.width);\n                            break;\n                        case 'cell':\n                            positionCellDecoratorFromViewCellRange(decorator, boundingBox);\n                            break;\n                    }\n                } else if (decorator.space === 'virtual' || decorator.space === 'data') {\n                    switch (decorator.units) {\n                        case 'px':\n                            break;\n                        case 'cell':\n                            /* jshint -W086 */\n                        default:\n                            var range = createRangeForDescriptor(decorator);\n                            var realCellRange = grid.viewPort.intersect(range);\n                            if (realCellRange) {\n                                positionCellDecoratorFromViewCellRange(realCellRange, boundingBox);\n                            } else {\n                                positionDecorator(boundingBox, -1, -1, -1, -1);\n                            }\n                            break;\n                            /* jshint +W086 */\n                    }\n\n                }\n            }\n        });\n\n        removeDecorators(grid.decorators.popAllDead());\n    };\n\n    function removeDecorators(decorators) {\n        decorators.forEach(function(decorator) {\n            var boundingBox = decorator.boundingBox;\n            if (boundingBox) {\n                // if they rendered an element previously we attached it to the bounding box as the only child\n                var renderedElement = boundingBox.firstChild;\n                if (renderedElement) {\n                    // create a destroy dom event that bubbles\n                    var destroyEvent = customEvent('decorator-destroy', true);\n                    renderedElement.dispatchEvent(destroyEvent);\n                }\n                decoratorContainer.removeChild(boundingBox);\n                decorator.boundingBox = undefined;\n            }\n        });\n    }\n\n    /* END DECORATOR LOGIC */\n\n    /* CELL CLASSES LOGIC */\n    viewLayer._drawCellClasses = function() {\n        grid.viewPort.iterateCells(function(r, c) {\n            var classes = grid.cellClasses.getCachedClasses(grid.view.row.toVirtual(r), grid.view.col.toVirtual(c));\n            cells[r][c].className = classes.join(' ');\n        });\n    };\n\n    /* END CELL CLASSES LOGIC*/\n\n    viewLayer.setTextContent = function(elem, text) {\n        if (elem.firstChild && elem.firstChild.nodeType === 3) {\n            elem.firstChild.nodeValue = text;\n        } else {\n            elem.textContent = text;\n        }\n    };\n\n    function destroyPreviouslyBuilt(built) {\n        if (!built) {\n            return;\n        }\n        Object.keys(built).forEach(function(key) {\n            destroyRenderedElems(built[key]);\n        });\n    }\n\n    function cleanup() {\n        removeDecorators(grid.decorators.getAlive().concat(grid.decorators.popAllDead()));\n        destroyPreviouslyBuilt(builtCols);\n        destroyPreviouslyBuilt(builtRows);\n        if (!container) {\n            return;\n        }\n        var querySelectorAll = container.querySelectorAll('.' + GRID_VIEW_ROOT_CLASS);\n        for (var i = 0; i < querySelectorAll.length; ++i) {\n            var root = querySelectorAll[i];\n            container.removeChild(root);\n        }\n    }\n\n    grid.eventLoop.bind('grid-destroy', function() {\n        cleanup();\n        clearTimeout(viewLayer.draw.timeout);\n        viewLayer.draw = require('../no-op');\n    });\n\n    return viewLayer;\n};",
    "var util = require('../util');\nvar rangeUtil = require('../range-util');\nvar capitalize = require('capitalize');\nvar addDirtyProps = require('../add-dirty-props');\nvar debounce = require('../debounce');\n\nmodule.exports = function(_grid) {\n    var grid = _grid;\n    var dirtyClean = require('../dirty-clean')(grid);\n    var container;\n\n    var viewPort = addDirtyProps({}, ['rows', 'cols', 'width', 'height'], [dirtyClean]);\n    viewPort.rows = 0;\n    viewPort.cols = 0;\n    viewPort.isDirty = dirtyClean.isDirty;\n\n    // these probably trigger reflow so we may need to think about caching the value and updating it at on draws or something\n    function getFirstClientRect() {\n        return container && container.getClientRects && container.getClientRects() && container.getClientRects()[0] || {};\n    }\n\n    Object.defineProperty(viewPort, 'top', {\n        enumerable: true,\n        get: function() {\n            return getFirstClientRect().top || 0;\n        }\n    });\n\n    Object.defineProperty(viewPort, 'left', {\n        enumerable: true,\n        get: function() {\n            return getFirstClientRect().left || 0;\n        }\n    });\n\n    viewPort.toGridX = function(clientX) {\n        return clientX - viewPort.left;\n    };\n\n    viewPort.toGridY = function(clientY) {\n        return clientY - viewPort.top;\n    };\n\n\n    var fixed = {\n        rows: 0,\n        cols: 0\n    };\n\n    function getFixed(rowOrCol) {\n        return fixed[rowOrCol + 's'];\n    }\n\n    viewPort.sizeToContainer = function(elem) {\n        container = elem;\n        viewPort.width = elem.offsetWidth;\n        viewPort.height = elem.offsetHeight;\n        viewPort.rows = calculateMaxLengths(viewPort.height, grid.rowModel);\n        viewPort.cols = calculateMaxLengths(viewPort.width, grid.colModel);\n        grid.eventLoop.fire('grid-viewport-change');\n    };\n\n    viewPort._onResize = debounce(function() {\n        viewPort._resize();\n    }, 200);\n\n    grid.eventLoop.bind('grid-destroy', function() {\n        clearTimeout(viewPort._onResize.timeout);\n        clearTimeout(shortDebouncedResize.timeout);\n    });\n\n    viewPort._resize = function() {\n        if (container) {\n            viewPort.sizeToContainer(container);\n        }\n    };\n\n    var shortDebouncedResize = debounce(function() {\n        viewPort._resize();\n    }, 1);\n\n    viewPort.shortDebouncedResize = shortDebouncedResize;\n\n\n    grid.eventLoop.bind('resize', window, function() {\n        //we don't bind the handler directly so that tests can mock it out\n        viewPort._onResize();\n    });\n\n    grid.eventLoop.bind('grid-row-change', function() {\n        fixed.rows = grid.rowModel.numFixed();\n        shortDebouncedResize();\n    });\n\n    grid.eventLoop.bind('grid-col-change', function() {\n        fixed.cols = grid.colModel.numFixed();\n        shortDebouncedResize();\n    });\n\n    function convertRealToVirtual(coord, rowOrCol, coordIsVirtual) {\n        // could cache this on changes i.e. row-change or col-change events\n        var numFixed = getFixed(rowOrCol);\n        if (coord < numFixed) {\n            return coord;\n        }\n        return coord + (coordIsVirtual ? -1 : 1) * grid.cellScrollModel[rowOrCol];\n    }\n\n    // converts a viewport row or column to a real row or column\n    // clamps it if the column would be outside the range\n    function getVirtualRowColUnsafe(realCoord, rowOrCol) {\n        return convertRealToVirtual(realCoord, rowOrCol);\n    }\n\n    function getVirtualRowColClamped(viewCoord, rowOrCol) {\n        var virtualRowCol = getVirtualRowColUnsafe(viewCoord, rowOrCol);\n        return grid.virtualPixelCellModel['clamp' + capitalize(rowOrCol)](virtualRowCol);\n    }\n\n    viewPort.toVirtualRow = function(r) {\n        return getVirtualRowColClamped(r, 'row');\n    };\n\n    viewPort.toVirtualCol = function(c) {\n        return getVirtualRowColClamped(c, 'col');\n    };\n\n    function getRealRowColClamped(virtualCoord, rowOrCol) {\n        var numFixed = getFixed(rowOrCol);\n        if (virtualCoord < numFixed) {\n            return virtualCoord;\n        }\n        var maxViewPortIndex = viewPort[rowOrCol + 's'] - 1;\n        return util.clamp(virtualCoord - grid.cellScrollModel[rowOrCol], numFixed, maxViewPortIndex, true);\n    }\n\n    viewPort.rowIsInView = function(virtualRow) {\n        var realRow = viewPort.toRealRow(virtualRow);\n        return !isNaN(realRow) && getLengthBetweenViewCoords(0, realRow, 'row', 'height', true) < viewPort.height;\n    };\n\n    viewPort.colIsInView = function(virtualCol) {\n        var realCol = viewPort.toRealCol(virtualCol);\n        return !isNaN(realCol) && getLengthBetweenViewCoords(0, realCol, 'col', 'width', true) < viewPort.width;\n    };\n\n\n    // default unclamped cause that seems to be the more likely use case converting this direction\n    viewPort.toRealRow = function(virtualRow) {\n        return getRealRowColClamped(virtualRow, 'row');\n    };\n\n    viewPort.toRealCol = function(virtualCol) {\n        return getRealRowColClamped(virtualCol, 'col');\n    };\n\n    viewPort.clampRow = function(r) {\n        return util.clamp(r, 0, viewPort.rows - 1);\n    };\n\n    viewPort.clampCol = function(c) {\n        return util.clamp(c, 0, viewPort.cols - 1);\n    };\n\n    viewPort.clampY = function(y) {\n        return util.clamp(y, 0, viewPort.height);\n    };\n\n    viewPort.clampX = function(x) {\n        return util.clamp(x, 0, viewPort.width);\n    };\n\n    function getLengthBetweenViewCoords(startCoord, endCoord, rowOrCol, heightOrWidth, inclusive) {\n        var rowOrColCap = capitalize(rowOrCol);\n        var toVirtual = viewPort['toVirtual' + rowOrColCap];\n        var lengthFn = grid.virtualPixelCellModel[heightOrWidth];\n        var clampFn = viewPort['clamp' + rowOrColCap];\n        var pos = 0;\n        var numFixed = getFixed(rowOrCol);\n        var isInNonfixedArea = endCoord >= numFixed;\n        var isInFixedArea = startCoord < numFixed;\n        var exclusiveOffset = (inclusive ? 0 : 1);\n        if (isInFixedArea) {\n            var fixedEndCoord = (isInNonfixedArea ? numFixed - 1 : endCoord - exclusiveOffset);\n            pos += lengthFn(startCoord, fixedEndCoord);\n        }\n        if (isInNonfixedArea) {\n            pos += lengthFn((isInFixedArea ? toVirtual(numFixed) : toVirtual(startCoord)), toVirtual(clampFn(endCoord)) - exclusiveOffset);\n        }\n        return pos;\n    }\n\n    function getTopOrLeft(endCoord, rowOrCol, heightOrWidth) {\n        return getLengthBetweenViewCoords(0, endCoord, rowOrCol, heightOrWidth);\n    }\n\n    viewPort.getRowTop = function(viewPortCoord) {\n        return getTopOrLeft(viewPortCoord, 'row', 'height');\n    };\n\n    viewPort.getColLeft = function(viewPortCol) {\n        return getTopOrLeft(viewPortCol, 'col', 'width');\n    };\n\n    viewPort.toPx = function(realCellRange) {\n        return {\n            top: viewPort.getRowTop(realCellRange.top),\n            left: viewPort.getColLeft(realCellRange.left),\n            height: getLengthBetweenViewCoords(realCellRange.top, realCellRange.top + realCellRange.height - 1, 'row', 'height', true),\n            width: getLengthBetweenViewCoords(realCellRange.left, realCellRange.left + realCellRange.width - 1, 'col', 'width', true)\n        };\n    };\n\n    function getRowOrColFromPosition(pos, rowOrCol, heightOrWidth, returnVirtual) {\n        // we could do this slighly faster with binary search to get log(n) instead of n, but will only do it if we actually need to optimize this\n        var rowOrColCap = capitalize(rowOrCol);\n        var viewMax = viewPort[rowOrCol + 's'];\n        var toVirtual = viewPort['toVirtual' + rowOrColCap];\n        var lengthFn = grid.virtualPixelCellModel[heightOrWidth];\n        var summedLength = 0;\n        for (var i = 0; i < viewMax; i++) {\n            var virtual = toVirtual(i);\n            var length = lengthFn(virtual);\n            var newSum = summedLength + length;\n            if (newSum > pos) {\n                return returnVirtual ? virtual : i;\n            }\n            summedLength = newSum;\n        }\n        return NaN;\n    }\n\n    viewPort.getVirtualRowByTop = function(top) {\n        return getRowOrColFromPosition(top, 'row', 'height', true);\n    };\n\n    viewPort.getVirtualColByLeft = function(left) {\n        return getRowOrColFromPosition(left, 'col', 'width', true);\n    };\n\n    viewPort.getRowByTop = function(top) {\n        return getRowOrColFromPosition(top, 'row', 'height');\n    };\n\n    viewPort.getColByLeft = function(left) {\n        return getRowOrColFromPosition(left, 'col', 'width');\n    };\n\n    viewPort.getRowHeight = function(viewPortRow) {\n        return grid.virtualPixelCellModel.height(viewPort.toVirtualRow(viewPort.clampRow(viewPortRow)));\n    };\n\n    viewPort.getColWidth = function(viewPortCol) {\n        return grid.virtualPixelCellModel.width(viewPort.toVirtualCol(viewPort.clampCol(viewPortCol)));\n    };\n\n    function intersectRowsOrCols(intersection, range, topOrLeft, rowOrCol, heightOrWidth) {\n        var numFixed = fixed[rowOrCol + 's'];\n        var fixedRange = [0, numFixed];\n\n        var virtualRange = [range[topOrLeft], range[heightOrWidth]];\n        var fixedIntersection = rangeUtil.intersect(fixedRange, virtualRange);\n        var scrollRange = [numFixed, viewPort[rowOrCol + 's'] - numFixed];\n        virtualRange[0] -= grid.cellScrollModel[rowOrCol];\n        var scrollIntersection = rangeUtil.intersect(scrollRange, virtualRange);\n        var resultRange = rangeUtil.union(fixedIntersection, scrollIntersection);\n        if (!resultRange) {\n            return null;\n        }\n\n        intersection[topOrLeft] = resultRange[0];\n        intersection[heightOrWidth] = resultRange[1];\n        return intersection;\n    }\n\n    viewPort.intersect = function(range) {\n        // assume virtual cells for now\n        var intersection = intersectRowsOrCols({}, range, 'top', 'row', 'height');\n        if (!intersection) {\n            return null;\n        }\n        return intersectRowsOrCols(intersection, range, 'left', 'col', 'width');\n    };\n\n\n    function calculateMaxLengths(totalLength, lengthModel) {\n        var lengthMethod = lengthModel.width && grid.virtualPixelCellModel.width || grid.virtualPixelCellModel.height;\n        var numFixed = lengthModel.numFixed();\n        var windowLength = 0;\n        var maxSize = 0;\n        var fixedLength = 0;\n        var windowStartIndex = numFixed;\n\n        for (var fixed = 0; fixed < numFixed; fixed++) {\n            fixedLength += lengthMethod(fixed);\n        }\n\n        // it might be safer to actually sum the lengths in the virtualPixelCellModel but for now here is ok\n        for (var index = numFixed; index < lengthModel.length(true); index++) {\n            var lengthOfIindex = lengthMethod(index);\n            windowLength += lengthOfIindex;\n            while (windowLength + fixedLength > totalLength && windowStartIndex < index) {\n                windowLength -= lengthMethod(windowStartIndex);\n                windowStartIndex++;\n            }\n            var windowSize = index - windowStartIndex + 1; // add the one because we want the last index that didn't fit\n            if (windowSize > maxSize) {\n                maxSize = windowSize;\n            }\n\n        }\n        return Math.min(maxSize + numFixed + 1, grid.virtual[lengthModel.width ? 'col' : 'row'].count());\n    }\n\n\n    viewPort.iterateCells = function(cellFn, optionalRowFn, optionalMaxRow, optionalMaxCol) {\n        optionalMaxRow = optionalMaxRow || Infinity;\n        optionalMaxCol = optionalMaxCol || Infinity;\n        for (var r = 0; r < Math.min(viewPort.rows, optionalMaxRow); r++) {\n            if (optionalRowFn) {\n                optionalRowFn(r);\n            }\n            if (cellFn) {\n                for (var c = 0; c < Math.min(viewPort.cols, optionalMaxCol); c++) {\n                    cellFn(r, c);\n\n                }\n            }\n        }\n    };\n\n    return viewPort;\n}",
    "var util = require('../util');\n\nmodule.exports = function (_grid) {\n    var grid = _grid;\n    var model = {};\n\n    //all pixels are assumed to be in the virtual world, no real world pixels are dealt with here :)\n    model.getRow = function (topPx) {\n        if (topPx < 0) {\n            return NaN;\n        }\n        var sumLength = 0;\n        for (var r = 0; r < grid.rowModel.length(true); r++) {\n            sumLength += grid.rowModel.height(r);\n            if (topPx < sumLength) {\n                return r;\n            }\n        }\n        return NaN;\n    };\n\n    //yes these are very similar but there will be differences\n    model.getCol = function (leftPx) {\n        if (leftPx < 0) {\n            return NaN;\n        }\n        var sumLength = 0;\n        for (var c = 0; c < grid.colModel.length(true); c++) {\n            sumLength += grid.colModel.width(c);\n            if (leftPx < sumLength) {\n                return c;\n            }\n        }\n        return NaN;\n    };\n\n\n    function clampRowOrCol(virtualRowCol, rowOrCol) {\n        var maxRowCol = grid[rowOrCol + 'Model'].length(true) - 1;\n        return util.clamp(virtualRowCol, 0, maxRowCol);\n    }\n\n    model.clampRow = function (virtualRow) {\n        return clampRowOrCol(virtualRow, 'row');\n    };\n\n    model.clampCol = function (virtualCol) {\n        return clampRowOrCol(virtualCol, 'col');\n    };\n\n    //for now these just call through to the row and column model, but very likely it will need to include some other calculations\n    model.height = function (virtualRowStart, virtualRowEnd) {\n        return heightOrWidth(virtualRowStart, virtualRowEnd, 'row');\n    };\n\n    model.width = function (virtualColStart, virtualColEnd) {\n        return heightOrWidth(virtualColStart, virtualColEnd, 'col');\n    };\n\n    function heightOrWidth(start, end, rowOrCol) {\n        var length = 0;\n        if (end < start) {\n            return 0;\n        }\n        end = util.isNumber(end) ? end : start;\n        end = clampRowOrCol(end, rowOrCol);\n        start = clampRowOrCol(start, rowOrCol);\n        var lengthModel = grid[rowOrCol + 'Model'];\n        var lengthFn = lengthModel.width || lengthModel.height;\n        for (var i = start; i <= end; i++) {\n            length += lengthFn(i);\n        }\n        return length;\n    }\n\n    model.totalHeight = function () {\n        return model.height(0, grid.rowModel.length(true) - 1);\n    };\n\n    model.totalWidth = function () {\n        return model.width(0, grid.colModel.length(true) - 1);\n    };\n\n    model.fixedHeight = function () {\n        return model.height(0, grid.rowModel.numFixed() - 1);\n    };\n\n    model.fixedWidth = function () {\n        return model.width(0, grid.colModel.numFixed() - 1);\n    };\n\n    function sizeChangeListener() {\n        //for now we don't cache anything about this so we just notify\n        grid.eventLoop.fire('grid-virtual-pixel-cell-change');\n    }\n\n    grid.eventLoop.bind('grid-col-change', sizeChangeListener);\n    grid.eventLoop.bind('grid-row-change', sizeChangeListener);\n\n    return model;\n};"
  ]
}